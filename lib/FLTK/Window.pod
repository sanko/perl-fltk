=pod

=head1 NAME

FLTK::Window - The base class for all FLTK Windows

=head1 Description

This widget produces an actual window. This can either be a main window,
with a border and title and all the window management controls, or a
"subwindow" inside a window. This is controlled by whether or not the
window has a L<C<parent( )>|/"parent ( )">. Internally there are now
significant differences between "main" windows and "subwindows" and these
really should be different classes, they are the same for historic FLTK
reasons.

Once you create a window, you usually add children
L<Widgets|FLTK::Widget> to it by using L<C<add(child)>|/"add( )"> or by
using L<C<begin( )>|/begin( )> and then constructing the children. See
L<C<FLTK::Group>|FLTK::Group> for more information on how to add and
remove children.

There are several subclasses of L<C<FLTK::Window>|FLTK::Window> that
provide double-buffering, overlay, menu, and OpenGL support.

The window's callback is done if the user tries to close a window using
the window manager and L<C<FLTK::modal( )>|FLTK/"modal( )"> is zero or
equal to the window. Window has a default callback that calls
L<C<hide( )>|/"hide ( )"> and calls C<exit(0)> if this is the last top-
level window.

You can set the L<C<shortcut( )>|/shortcut ( )> and then that key will
call the callback. If you don't change it then that key will close the
window.

=head1 Constructor

This class supports two basic constructors.

=over

=item C<new ( x, y, w, h, [label = ''], [begin = 0] )>

This constructor is for I<child> windows. You should use the constructor
with just W and H for normal parent windows. This constructor leaves
L<C<visible( )>|/visible ( )> true, so the child window will appear when
the parent window has L<C<show( )>|/show ( )> called.

WARNING: this is misleading if this is B<not> a child window, call
L<C<clear_visible( )>|/clear_visible ( )> for top-level ones.

=item C<new ( w, h, [label = ''] )>

This form of the constructor should be used for a "top-level" window
(that is, one that is not inside another window). It correctly sets
L<C<visible( )>|/visible ( )> to false and L<C<parent( )>|/parent ( )> to
C<undef>. By not specifying the position of the window, the window system
will pick a place to show the window (some older X window managers will
allow the user to place the window by hand). If you want to force a
position you should call L<C<position( )>|/position ( x, y )> or
L<C<hotspot( )>|/hotspot ( )> before calling L<C<show( )>|/show ( )>.

=back

=head1 Methods

=over

=item C<label ( name )>

Sets the window title, which is drawn in the titlebar by the system.

=item C<iconlabel ( iname )>

Sets the text displayed below the icon (or in the taskbar). If you don't
set this it defaults to the L<C<label( )>|/"label ( name )"> but if that
appears to be a filename, it defaults to the last portion after the last
C</> character.

=item C<label ( name, iname )>

Sets both the L<C<label( )>|/"label ( name )"> and the
L<C<iconlabel( )>|/"iconlabel ( iname )">.

=item C<border ( set )>

If set to C<true>, then a window border will be set, otherwise the window
will have neither border nor caption.

=item C<child_of ( FLTK::Window parent )>

Tell the system that this window will not have an icon, it will
dissappear and reappear when parent is iconized or shown, and it is
forced to always be above parent. On X this is called a "Transient
window", and Windows calls this a "overlapping child". parent is
different than the L<C<parent( )>|/"parent ( )">, which must be zero.

Changing this value causes C<DESTROY> to be called, due to stupid
limitations in X and Windows.

Win32 and some X window managers have an annoying bug where calling
L<C<show( )>|/"show ( )"> on this will also raise the parent window to
right below this, making many useful user interface designs impossible!

If you want a dialog that blocks interaction with the other windows of
your application or with all other applications, you need to look at
L<C<exec( )>|/"exec ( )"> (or possibly
L<C<FLTK::modal( )>|FLTK/"modal ( )">).

=item C<double_buffer ( )>

Returns true if
L<C<set_double_buffer( )>|/"set_double_buffer ( )"> was called, returns
C<false> if L<C<clear_double_buffer( )>|/"clear_double_buffer ( )"> was
called. If neither has been called this returns a machine-dependent state
(systems where double buffering is efficient turn it on by default).

=item C<set_double_buffer ( )>

If the window is double-buffered, all drawing is done first to some
offscreen image, and then copied to the screen as a single block. This
eliminates blinking as the window is updated, and often the application
looks faster, even if it actually is slower.

=item C<clear_double_buffer ( )>

Turn off double buffering, so that drawing directly goes to the visible
image on the screen. Not all systems can do this, they will remain double
buffered even if this is off.

=item C<free_backbuffer ( )>

Get rid of extra storage created by drawing when
L<C<double_buffer( )>|/"double_buffer ( )"> was turned on.

=item C<draw_overlay ( )>

A subclass of Window can define this method to draw an "overlay" image
that appears atop everything else in the window. This will only be called
if you call L<C<redraw_overlay( )>|/"redraw_overlay ( )"> on the
L<C<shown( )>|/"shown ( )"> window, and it will stop being called if you
call erase_overlay().

This is designed for a fast-changing graphic such as a selection
rectangle. The implementation is to put the window into
L<C<double_buffer( )>|/"double_buffer ( )"> mode, and then set things so
the on-screen image is being drawn before this method is called. The
previous overlay image was erased before calling this by copying the back
buffer to the front. Notice that the overlay will blink as you redraw it,
you must trade off this annoyance against the slower update of the
overlay if you just draw it normally in the L<C<draw( )>|/"draw ( )">
method.

Some systems don't allow drawing in the front buffer. In this case the
entire back buffer is redrawn and the overlay drawn atop it.

The default version draws a red rectangle, so that mistaken calls to
L<C<redraw_overlay( )>|/"redraw_overlay ( )"> are detectable.

=item C<redraw_overlay ( )>

Indicate that the image made by L<C<draw_overlay( )>|/"draw_overlay ( )">
hs changed and must be drawn or redrawn. If the image is blank, you
should call L<C<erase_overlay( )>|/"erase_overlay ( )">

This does nothing if the window is not L<C<shown( )>|/"shown ( )">, it is
assume that overlays are only drawn in response to user input.

=item C<erase_overlay ( )>

Indicate that the overlay drawn with
L<C<draw_overlay( )>|/"draw_overlay ( )"> is blank.
L<C<draw_overlay( )>|/"draw_overlay ( )"> will not be called until
L<C<redraw_overlay( )>|/"redraw_overlay ( )"> is called again.

=item C<hotspot	( x, y, [offscreen] )>

L<C<position( )>|/"position ( )"> the window so that the mouse is
pointing at the C<x, y> position. If C<offscreen> is C<true> then the
window is allowed to extend off the L<Monitor|FLTK::Monitor> (some X
window managers do not allow this).

=item C<hotspot( FLTK::Widget, [offscreen] )>

L<C<position( )>|/"position ( )"> the window so that the mouse is
pointing at the center of the widget, which may be the window itself. If
C<offscreen> is C<true> then the window is allowed to extend off the
L<Monitor|FLTK::Monitor> (some X window managers do not allow this).

=back

=head1 Notes

=head2 Destruction

The destructor I<also deletes all the children>. This allows a whole tree
to be deleted at once, without having to keep a pointer to all the
children in the user code. A kludge has been done so the Window and all
of it's children can be automatic (local) variables, but you must declare
the Window first so that it is destroyed last.

=head1 Disclaimer

This document and the specification behind it are subject to change.
All modifications will be documented in the Changes file included with
this distribution.  All versions of this file can be found in the
project's git repository.

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id: Window.pod 17a67d8 2009-03-24 05:37:20Z sanko@cpan.org $ forgot=

=cut
