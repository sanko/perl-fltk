#ifndef DISABLE_GROUP

MODULE = FLTK               PACKAGE = FLTK::Group

=pod

=head1 Description

The L<FLTK::Group|FLTK::Group> class is the FLTK container widget. It
maintains an array of child widgets. These children can themselves be any
widget including L<FLTK::Group|FLTK::Group>, nesting groups allows much more
control over layout and resize behavior. Nested groups are also necessary to
group radio buttons together.

By default L<FLTK::Group|FLTK::Group> preserves the positions and sizes of all
it's children, they do not move no matter what sizes or other children are
added or removed.

Setting L<C<resizable()>|/"resizable"> will change the layout behavior so that
it responds to resizing by moving or resizing the children to fit. See below
for details.

You may want to use an L<FLTK::Pack|FLTK::Pack> or a
L<FLTK::Scroll|FLTK::Scroll> to get other common layout behavior that can
respond to changes in the sizes of child widgets.

The most-used subclass of L<FLTK::Group|FLTK::Group> is
L<FLTK::Window|FLTK::Window>, all the rules about resizing apply to windows.
Setting L<C<resizable()>|/"resizable"> on a window will allow the user to
resize it. If you want different behavior (such as from
L<FLTK::Pack|FLTK::Pack>) for your window you should make the window have that
as a single resizable child that fills it.

L<FLTK::Menu|FLTK::Menu> is a subclass and thus all menus and browsers are
groups and the items in them are widgets.

Inherits L<FLTK::Widget|FLTK::Widget>.

Inherited by L<FLTK::AlignGroup|FLTK::AlignGroup>,
L<FLTK::BarGroup|FLTK::BarGroup>, L<FLTK::ColorChooser|FLTK::ColorChooser>,
L<FLTK::HelpView|FLTK::HelpView>, L<FLTK::Menu|FLTK::Menu>,
L<FLTK::PackedGroup|FLTK::PackedGroup>,
L<FLTK::ScrollGroup|FLTK::ScrollGroup>,
L<FLTK::StatusBarGroup|FLTK::StatusBarGroup>,
L<FLTK::TabGroup|FLTK::TabGroup>, L<FLTK::TextDisplay|FLTK::TextDisplay>,
L<FLTK::TiledGroup|FLTK::TiledGroup>, L<FLTK::Window|FLTK::Window>, and
L<FLTK::WizardGroup|FLTK::WizardGroup>.

=cut

#include <fltk/Group.H>

Group *
Group::new ( X, Y, W, H, LABEL = 0, BEGIN = false )
    int X
    int Y
    int W
    int H
    char * LABEL
    bool BEGIN

#if ALLOW_DESTROY

bool
Group::DESTROY ( )
    CODE:
#if VERBOSE >= 2
        warn ( "Bye, Group (label: %s)", THIS->label() );
#endif
        delete THIS;
        RETVAL = true;
    OUTPUT:
        RETVAL

#endif

=for apidoc |||begin|

L<C<begin()>|/"begin"> sets the current group so you can build the widget tree
by just constructing the widgets. L<C<begin()>|/"begin"> is exactly the same
as L<C<current(this)>|/"current">.

B<Don't forget to L<C<end()>|/"end"> the group or window!>

=cut

=for apidoc |||clear|

I<Deletes> all children from the group and makes it empty. This calls the
destructor on all the children!!!

=cut

=for apidoc |||draw|

NFI

=cut

=for apidoc |||end|

L<C<end()>|/"end"> is exactly the same as
C<L<current($self->L<parent()|/"parent">)|/"current">. Any new widgets added
to the widget tree will be added to the parent of the group.

=cut

=for apidoc |||fix_old_positons|

If this is a L<Group|FLTK::Group> and not a L<Window|FLTK::Window>, subtract
L<C<x()>|/"x"> and L<C<y()>|/"y"> from the position of all children. This will
fix the positions of widgets created for fltk1.1 that are inside a group.

=cut

=for apidoc |||init_sizes|

Indicate that all the remembered child sizes should be reinitialized.

The group remembers the initial size of itself and all it's children, so that
the layout can be restored even if the group is resized so that some children
go to zero or negative sizes.

This can produce unwanted behavior if you try to rearrange the child widgets
yourself, as the next resize will put them right back where they were
initially. Call this to make it forget all the saved sizes and reinitialize them during the next layout().

This is automatically done when any child is added or removed.

=cut

=for apidoc |||layout|

NFI

=cut

=for apidoc |||remove_all|

Removes all widgets from the group. This does not call the destructor on the
child widget (see L<C<clear()>|/"clear">).

=cut

void
Group::begin( )
    ALIAS:
        clear             = 1
        draw              = 2
        end               = 3
        fix_old_positions = 4
        init_sizes        = 5
        layout            = 6
        remove_all        = 7
    CODE:
        switch( ix ) {
            case 0: THIS->begin();             break;
            case 1: THIS->clear();             break;
            case 2: THIS->draw();              break;
            case 3: THIS->end();               break;
            case 4: THIS->fix_old_positions(); break;
            case 5: THIS->init_sizes();        break;
            case 6: THIS->layout();            break;
            case 7: THIS->remove_all();        break;
        }

=for apidoc |||add|FLTK::Widget

The widget is removed from it's current group (if any) and then added to the
end of this group.

References L<C<insert()>|/"insert">.

=cut

=for apidoc |||add_resizable|FLTK::Widget

NFI

=cut

=for apidoc |||set_focus|WIDGET

NFI

=cut

void
Group::add( widget )
    Widget * widget
    ALIAS:
        add_resizable = 1
        set_focus     = 2
    CODE:
        switch( ix ) {
            case 0: THIS->add( widget );            break;
            case 1: THIS->add_resizable( *widget ); break;
            case 2: THIS->set_focus( widget );      break;
        }


=for apidoc |int|FLTK::Group|children|

Returns how many child widgets the group has.

=cut

=for apidoc |int|FLTK::Group|navigation_key|

Turn C<Tab> into C<Right> or C<Left> for keyboard navigation

=cut

int
Group::children( )
    ALIAS:
        navigation_key = 1
    CODE:
        switch( ix ) {
            case 0: THIS->children( );       break;
            case 1: THIS->navigation_key( ); break;
        }


=for apidoc |||find|WIDGET

Searches the children for C<WIDGET>, returns the index of C<WIDGET> or of a
parent of widget that is a L<C<child()>|/"child"> of this. Returns
L<C<children()>|/"children"> if the widget is C<NULL> or not found.

=cut

int
Group::find ( widget )
    Widget * widget
    C_ARGS: (const Widget *) widget

=cut

=for apidoc |||remove|index

If C<index> is an integer, the C<index>th widget is removed from the group.

=cut

=for apidoc |||remove|widget

Removes the C<widget> from the group. This does nothing if the C<widget> is
not currently a child of this group.

=cut

void
Group::remove ( index )
    CASE: SvIOK( ST(1) )
        int index
    CASE:
        Widget * index
        C_ARGS: *index

 # The following probably needs refactoring

=for apidoc ||FLTK::Widget|child|INDEX

Returns a child, C<INDEX >= 0 && INDEX < L<children()|/"children">>. B<No
range checking is done!>

Reimplemented in L<FLTK::Menu|FLTK::Menu>.

=cut

Widget *
Group::child ( INDEX )
    int INDEX

=for apidoc ||int|focus_index|

The index of the widget that contains the focus. You can initialize this
before the group is displayed. Changing it while it is displayed does not
work, use
C<L<$widget|FLTK::Widget>->L<take_focus()|FLTK::Widget/"take_focus">> instead.

For some subclasses such as L<FLTK::TabGroup|FLTK::TabGroup>, a negative
number indicates that the group itself has the focus. In most cases any
illegal value means it will search for any widget that accepts focus.

This is also used by L<FLTK::Menu|FLTK::Menu> to locate the item selected by
the user. See L<C<FLTK::Menu::get_item()>|FLTK::Menu/"get_item">.

Reimplemented in L<FLTK::Browser|FLTK::Browser/"focus_index">.

=cut

=for apidoc |||focus_index|INDEX

NFI

=cut

int
Group::focus_index ( INDEX = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->focus_index( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        int INDEX
        CODE:
            THIS->focus_index( INDEX );

=for apidoc ||int|handle|EVENT

Calls L<C<send()>|/"send"> on some or all of the children widgets.

Reimplemented from L<FLTK::Widget|FLTK::Widget>.

Reimplemented in L<FLTK::ItemGroup|FLTK::ItemGroup>.

=cut

int
Group::handle ( EVENT )
    int EVENT

=for apidoc |||insert|WIDGET|INDEX

NFI

=cut

=for apidoc |||insert|WIDGET|WIDGET2

This does L<C<insert(w, L<find(WIDGET2)|/"find">)|/"insert">. This will
append the widget if C<WIDGET2> is not in the group.

=cut

void
Group::insert ( WIDGET, INDEX )
    CASE: SvIOK( ST(2) )
        Widget * WIDGET
        int            INDEX
        C_ARGS: *WIDGET, INDEX
    CASE:
        Widget * WIDGET
        Widget * INDEX
        C_ARGS: *WIDGET, INDEX

=for apidoc |||replace|WIDGET|WIDGET2

Find C<WIDGET>, remove it, and insert C<WIDGET2> it its place. If C<WIDGET> is
not a child, C<WIDGET2> is appended to the end of the list.

=cut

=for apidoc |||replace|INDEX|WIDGET

Remove the C<INDEX>th widget and insert the passed C<WIDGET> in its place.

=cut

void
Group::replace ( WIDGET, WIDGET2 )
    CASE: SvIOK( ST(1) )
        int WIDGET
        Widget * WIDGET2
        C_ARGS: WIDGET, *WIDGET2
    CASE:
        Widget * WIDGET
        Widget * WIDGET2
        C_ARGS: *WIDGET, *WIDGET2

=for apidoc |||resizable|WIDGET

The resizable widget defines the resizing box for the group. When the group is
resized it calculates a new size and position for all of its children. Widgets
that are horizontally or vertically inside the dimensions of the box are
scaled to the new size. Widgets outside the box are moved.

I<Please see fltk's docs for pretty pictures...>

The resizable may be set to the group itself, in which case all the contents
are resized. If the resizable is C<NULL> (the default) then all widgets remain
a fixed size and distance from the top-left corner.

It is possible to achieve any type of resize behavior by using an
L<InvisibleBox|FLTK::InvisibleBox> as the resizable and/or by using a
hierarchy of child L<FLTK::Group|FLTK::Group>'s.

=cut

=for apidoc ||FLTK::Widget|resizable|

NFI

=cut

Widget *
Group::resizable( WIDGET = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->resizable( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        Widget * WIDGET
        CODE:
            THIS->resizable( WIDGET );

=for apidoc |||resize_align|Flags

NFI

=cut

=for apidoc ||Flags|resize_align|

NFI

=cut

Flags
Group::resize_align( FLAGS = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->resize_align( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        Flags FLAGS
        CODE:
            THIS->resize_align( FLAGS );



=for apidoc |||swap|INDEXA|INDEXB

NFI

=cut

void
Group::swap( INDEXA, INDEXB )
    int INDEXA
    int INDEXB

 # Static Public Member Functions

=for apidoc |||current|group

Sets the group being currently built.

=cut

=for apidoc ||FLTK::Group|current|

Returns the group being currently built. The
L<FLTK::Widget|FLTL::Widget/"new"> constructor automatically does
C<L<current()|/"current"->L<add(widget)|/"add">> if this is not null. To
prevent new widgets from being added to a group, call
L<C<Group::current(0)>|FLTK::Group/"current">.

=cut

Group *
Group::current ( GROUP = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->current( );
        OUTPUT:
            RETVAL
    CASE:
        Group * GROUP
        CODE:
            THIS->current( GROUP );


#endif // ifndef DISABLE_GROUP

=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut
