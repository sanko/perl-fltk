#include <fltk/Widget.H>

MODULE = FLTK               PACKAGE = FLTK::Widget

Widget *
Widget::new( x, y, w, h, l = PL_origfilename)
    int x
    int y
    int w
    int h
    char * l
    CODE:
        RETVAL = new Widget(x, y, w, h, l);
    OUTPUT:
        RETVAL

#bool
#Widget::DESTROY ( )

void
Widget::draw ( )

int
Widget::handle( EVENT )
    int EVENT

 # int
 # Widget::send ( EVENT )
 #    int EVENT

void
Widget::layout ( )

bool
Widget::copy_style ( STYLE )
    const Style * STYLE

Group *
Widget::parent ( )

Window *
Widget::window ( )

uchar
Widget::type ( )

bool
Widget::is_group ( )

bool
Widget::is_window ( )

bool
Widget::resize ( X, Y, W, H )
    CASE: items == 2
        int X
        int Y
        C_ARGS: X, Y
    CASE: items == 4
        int X
        int Y
        int W
        int H

bool
Widget::position ( X, Y )
    int X
    int Y

const char *
Widget::label ( STRING = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->label( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        const char * STRING
        CODE:
            THIS->label( STRING );

void
Widget::copy_label( STRING )
    const char * STRING

unsigned
Widget::shortcut ( KEY )
    CASE: ! items
        C_ARGS:
    CASE: items == 1
        unsigned KEY
        CODE:
            THIS->shortcut( KEY );

bool
Widget::add_shortcut ( KEY )
    unsigned KEY

bool
Widget::remove_shortcut ( KEY )
    unsigned KEY

void
Widget::remove_shortcuts ( )

unsigned
Widget::label_shortcut ( )

bool
Widget::test_label_shortcut ( )

bool
Widget::test_shortcut ( TEST_LABEL )
    CASE: ! items
        CODE:
            THIS->test_shortcut( );
    CASE: items == 1
        bool TEST_LABEL


 # TODO: Make this look more like the C++ version
void
Widget::callback( SUB, ARGS = NO_INIT, ... )
    CODE:
        AV *arr = newAV();
        av_store(arr, 0, newSVsv((SV*)ST(1))); // coderef
        SV * widget = newSVsv((SV*)ST(0));
#ifdef SvWEAKREF
        sv_rvweaken(widget);
#else
        croak("weak references are not implemented in this release of perl");
        XSRETURN_EMPTY;
#endif
        av_store(arr, 1, widget); // widget
        for (int i = 2; i < items; i++) {
            av_store(arr, i, newSVsv((SV*)ST(i)));
        }
        THIS->callback(cb);
        THIS->user_data(arr);

void
Widget::user_data ( DATA )
    void * DATA

void
Widget::argument ( VALUE )
    long VALUE

void
Widget::when ( WHEN )
    uchar WHEN

 # TODO: Make this look more like the C++ version
 # void
 # Widget::default_callback ( WIDGET, CODE )
 #     Widget * WIDGET
 #     CODE:
 #         AV *arr = newAV();
 #         av_store(arr, 0, newSVsv((SV*)ST(1))); // coderef
 #         av_store(arr, 1, newSVsv((SV*)ST(0))); // widget
 #         for (int i = 2; i < items; i++) {
 #             warn ( "%d | %s", i, newSVsv((SV*)ST(i)));
 #             av_store(arr, i, newSVsv((SV*)ST(i)));
 #         }
 #         THIS->default_callback(WIDGET, cb);
 #         THIS->user_data(arr);

void
Widget::do_callback ( WIDGET = NO_INIT, ARG = 0 )
    CASE: items == 1
        CODE:
            THIS->do_callback( );
    CASE: ! SvNOK(ST(1)) && ( items == 1 || items == 2 )
        Widget * WIDGET
        void   * ARG
    CASE:
        Widget * WIDGET
        long     ARG

bool
Widget::contains ( WIDGET )
    const Widget * WIDGET

bool
Widget::pushed ( )

bool
Widget::focused ( )

bool
Widget::belowmouse ( )

Flags
Widget::flags ( FLAGS = NO_INIT )
    CASE: ! items
        CODE:
            RETVAL = THIS->flags( );
    CASE: items == 1
        Flags FLAGS
        CODE:
            THIS->flags ( FLAGS );

void
Widget::set_flag ( FLAG, VALUE = true )
    CASE: items == 1
        unsigned FLAG
        C_ARGS: FLAG
    CASE: items == 2
        unsigned FLAG
        bool     VALUE

void
Widget::clear_flag ( FLAG )
    unsigned FLAG

void
Widget::invert_flag ( FLAG )
    unsigned FLAG

bool
Widget::flag ( FLAG )
    unsigned FLAG

bool
Widget::any_of ( FLAG )
    unsigned FLAG

bool
Widget::all_of ( FLAG )
    unsigned FLAG

bool
Widget::state ( STATE )
    CASE: ! items
        CODE:
            RETVAL = THIS->state( );
    CASE:
        bool STATE;

bool
Widget::clear ( )

void
Widget::setonly ( )

bool
Widget::visible_r ( )

void
Widget::show ( )

void
Widget::hide ( )

bool
Widget::active ( )

bool
Widget::active_r ( )

void
Widget::activate ( )

void
Widget::deactivate ( )

bool
Widget::output ( )

bool
Widget::horizontal ( )

bool
Widget::vertical ( )

void
Widget::set_horizontal ( )

void
Widget::set_vertical ( )

bool
Widget::take_focus ( )

void
Widget::throw_focus ( )

void
Widget::redraw ( FLAGS = NO_INIT )
    CASE: items == 1
        CODE:
            THIS->redraw( );
    # CASE: items == 2 && sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)
    #     const fltk::Rectangle * FLAGS
    CASE: items == 2
        uchar FLAGS

void
Widget::redraw_label ( )

void
Widget::redraw_highlight ( )

uchar
Widget::damage ( )

void
Widget::set_damage ( VALUE )
    uchar VALUE

void
Widget::relayout ( )

uchar
Widget::layout_damage ( VALUE )
    CASE: ! items
        PROTOTYPE: $;$
        CODE:
            RETVAL = THIS->layout_damage( );
    CASE:
        uchar VALUE
        CODE:
            THIS->layout_damage( VALUE );


void
Widget::add_timeout ( TIME )
    float TIME

void
Widget::repeat_timeout ( TIME )
    float TIME

void
Widget::remove_timeout (  )

void
Widget::make_current ( )

void
Widget::draw_background ( )

void
Widget::draw_frame ( )

void
Widget::draw_box ( )

void
Widget::draw_label ( RECTANGLE, FLAGS )
    CASE: ! items
        PROTOTYPE: $;$$
        CODE:
            THIS->draw_label( );
    CASE: items == 2
        const fltk::Rectangle * RECTANGLE
        Flags                   FLAGS
        C_ARGS: (const fltk::Rectangle &) RECTANGLE, FLAGS

void
Widget::draw_glyph ( WHICH, RECTANGLE )
    int WHICH
    const fltk::Rectangle * RECTANGLE
    C_ARGS: WHICH, (const fltk::Rectangle &) RECTANGLE

void
Widget::cursor ( CURSOR )
    Cursor * CURSOR

void
Widget::measure_label ( W, H )
    int W
    int H
    OUTPUT:
        W
        H

 # TODO: Make these work...

 # void
 # Widget::add ( ATYPE, DATA )
 #     const AssociationType * ATYPE
 #     void * DATA
 #     C_ARGS: (const AssociationType) ATYPE, DATA
 #     OUTPUT:
 #         ATYPE
 #
 # bool
 # Widget::set ( ATYPE, DATA )
 #     CASE: ! items
 #         PROTOTYPE: $;$$
 #         CODE:
 #             RETVAL = THIS->set( );
 #     CASE:
 #           AssociationType * ATYPE
 #         void * DATA
 #         C_ARGS: (const AssociationType) ATYPE, DATA
 #         OUTPUT:
 #             ATYPE
 #
 # void *
 # Widget::get ( ATYPE )
 #     const AssociationType ATYPE
 #     OUTPUT:
 #         ATYPE
 #
 # void *
 # Widget::foreach (   AssociationType & AT, AssociationFunctor & FKT )
 #
 # bool
 # Widget::remove (   AssociationType & AT, void * DATA )
 #
 # bool
 # Widget::find (   AssociationType & AT, void * DATA )

















































bool
Widget::add_shorcut( unsigned key )
    CODE:
        THIS->add_shortcut( key );
    OUTPUT:
        RETVAL


void
Widget::get_absolute_rect( ...)
    CODE:
        warn("TODO: THIS->get_absolute_rect(...)");






 # From fltk::Rectangle

int
Widget::x ( int x = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->x( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->x( x );
            RETVAL = THIS->x( ) == x ? true : false;
        OUTPUT:
            RETVAL

int
Widget::y ( int y = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->y( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->y( y );
            RETVAL = THIS->y( ) == y ? true : false;
        OUTPUT:
            RETVAL

int
Widget::w ( int w = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->w( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->w( w );
            RETVAL = THIS->w( ) == w ? true : false;
        OUTPUT:
            RETVAL

int
Widget::h ( int h = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->h( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->h( h );
            RETVAL = THIS->h( ) == h ? true : false;
        OUTPUT:
            RETVAL

int
Widget::r ( ... )
    CODE:
        RETVAL = THIS->r( );
    OUTPUT:
        RETVAL

int
Widget::b ( ... )
    CODE:
        RETVAL = THIS->b( );
    OUTPUT:
        RETVAL

bool
Widget::set_x ( int v )
    CODE:
        THIS->set_x( v );
        RETVAL = THIS->x( ) == v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::set_y ( int v )
    CODE:
        THIS->set_y( v );
        RETVAL = THIS->y( ) == v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::set_r ( int v )
    CODE:
        THIS->set_r( v );
        RETVAL = THIS->r( ) == v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::set_b ( int v )
    CODE:
        THIS->set_b( v );
        RETVAL = THIS->b( ) == v ? true : false;
    OUTPUT:
        RETVAL

 # bool
 # Widget::set(int x, int y, int w, int h)
 #     CODE:
 #         THIS->set(x, y, w, h);
 #         RETVAL = (
 #             (THIS->x( ) == x) and
 #             (THIS->y( ) == y) and
 #             (THIS->w( ) == w) and
 #             (THIS->h( ) == h)) ? true : false;
 #     OUTPUT:
 #         RETVAL


bool
Widget::move_x ( int v )
    CODE:
        int pre_x = THIS->x( );
        THIS->move_x( v );
        RETVAL = THIS->x( ) == pre_x + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move_y ( int v )
    CODE:
        int pre_y = THIS->y( );
        THIS->move_y( v );
        RETVAL = THIS->y( ) == pre_y + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move_r ( int v )
    CODE:
        int pre_r = THIS->r( );
        THIS->move_r( v );
        RETVAL = THIS->r( ) == pre_r + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move_b ( int v )
    CODE:
        int pre_b = THIS->b( );
        THIS->move_b( v );
        RETVAL = THIS->b( ) == pre_b + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::inset ( int v )
    CODE:
        int pre_w = THIS->w( );
        int pre_h = THIS->h( );
        THIS->inset( v );
        RETVAL = (
            (THIS->w( ) == pre_w - (v * 2)) and
            (THIS->h( ) == pre_h - (v * 2))
          ) ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move ( int dx, int dy )
    CODE:
        int pre_x = THIS->x( );
        int pre_y = THIS->y( );
        THIS->move( dx, dy );
        RETVAL = (
            (THIS->x( ) == pre_x + dx) and
            (THIS->y( ) == pre_y + dy)
          ) ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::empty ( )
    CODE:
        RETVAL = THIS->empty( );
    OUTPUT:
        RETVAL

bool
Widget::not_empty ( )
    CODE:
        RETVAL = THIS->not_empty( );
    OUTPUT:
        RETVAL

int
Widget::center_y ( )
    CODE:
        RETVAL = THIS->center_y( );
    OUTPUT:
        RETVAL

int
Widget::baseline_y ( )
    CODE:
        RETVAL = THIS->baseline_y( );
    OUTPUT:
        RETVAL

 # bool
 # Widget::contains ( int x, int y )
 #    CODE:
 #        RETVAL = THIS->contains( x, y );
 #    OUTPUT:
 #         RETVAL

 # TODO: void fltk::Rectangle::merge  (  const Rectangle &   r   )
 # Replace the value with the union of this rectangle and R (ie the rectangle
 # that surrounds both of these rectangles). If one rectangle is empty(), the
 # other is returned unchanged (ie it does not union in the degenerate point
 # of that rectangle).

 # TODO: void fltk::Rectangle::intersect  (  const Rectangle &   r   )
 # Replace the value with the intersection of this rectangle and R. If the
 # rectangles do not intersect, the result may have negative width and/or
 # height, this means empty() will return true, but some code may still draw
 # this rectangle.









 # Unknown...
float
Widget::labelsize( SIZE = 0 )
    CASE: items == 1
        CODE:
            RETVAL = THIS->labelsize( );
       OUTPUT:
            RETVAL
    CASE: items == 2
        int SIZE;
        CODE:
            THIS->labelsize(SIZE);

LabelType *
Widget::labeltype ( TYPE = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->labeltype( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        LabelType * TYPE
        CODE:
            THIS->labeltype( TYPE );

Font *
Widget::labelfont ( TYPE = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->labelfont( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        Font * TYPE
        CODE:
            THIS->labelfont( TYPE );

const char *
Widget::tooltip( char *tooltip = NO_INIT)
    CODE:
        if (items > 1) {
            THIS->tooltip(tooltip);
            RETVAL = (tooltip == THIS->tooltip()) ? tooltip : NULL;
        }
        else
            RETVAL = THIS->tooltip();
    OUTPUT:
        RETVAL

int
Widget::color(int color = NO_INIT)
    CODE:
        if (items > 1) {
            //group->box(lookup_box(color));
            THIS->color(color);
            RETVAL = (color == THIS->color()) ? color : NULL;
        }
        else
            RETVAL = THIS->color();
    OUTPUT:
        RETVAL

void
Widget::box( TYPE )
    Box * TYPE




 # From my own searching

Flags
Widget::align ( ALIGN = NO_INIT )
    CASE: items == 2
        unsigned ALIGN
        CODE:
            THIS->align( ALIGN );
    CASE:
        CODE:
            RETVAL = THIS->align( );
        OUTPUT:
            RETVAL

 # Children

INCLUDE: FLTK_Group.xsi

INCLUDE: FLTK_Button.xsi

 #
 # Copyright (C) 2009 by Sanko Robinson <sanko@cpan.org>
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of The Artistic License 2.0.  See the LICENSE file
 # included with this distribution or
 # http://www.perlfoundation.org/artistic_license_2_0.  For
 # clarification, see http://www.perlfoundation.org/artistic_2_0_notes.
 #
 # When separated from the distribution, all POD documentation is covered by
 # the Creative Commons Attribution-Share Alike 3.0 License.  See
 # http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
 # clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.
 #
 # $Id$
 #
