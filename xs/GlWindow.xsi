MODULE = FLTK               PACKAGE = FLTK::GlWindow

#if USE_GL

#include "subclass/GlWindow.h"

=pod

=head1 Description

Provides an area in which the L<C<draw()>|/"draw"> method can use OpenGL to
draw. This widget sets things up so OpenGL works, and also keeps an OpenGL
"context" for that window, so that changes to the lighting and projection may
be reused between redraws. L<GlWindow|FLTK::GlWindow> also flushes the OpenGL
streams and swaps buffers after L<C<draw()>|/"draw"> returns.

L<C<draw()>|/"draw"> is a pure virtual method. You must subclass
L<GlWindow|FLTK::GlWindow> and provide an implementation for
L<C<draw()>|/"draw">. You can avoid reinitializing the viewport and lights and
other things by checking L<C<valid()>|/"valid"> at the start of
L<C<draw()>|/"draw"> and only doing the initialization if it is false.

L<C<draw()>|/"draw"> can only use OpenGL calls. Do not attempt to call any of
the functions in L<<fltk/draw.h>>, or X or GDI32 or any other drawing api. Do
not call C<glstart()> or C<glfinish()>.

=head2 Double Buffering

Normally double-buffering is enabled. You can disable it by chaning the
L<C<mode()>|/"mode"> to turn off the L<C<DOUBLE_BUFFER>|/"DOUBLE_BUFFER"> bit.

If double-buffering is enabled, the back buffer is made current before
L<C<draw()>|/"draw"> is called, and the back and front buffers are
automatically swapped after L<C<draw()>|/"draw"> is completed.

Some tricks using the front buffer require you to control the swapping. You
can call L<C<swap_buffers()>|/"swap_buffers"> to swap them (OpenGL does not
provide a portable function for this, so we provide it). But you will need to
turn off the auto-swap, you do this by adding the
L<C<NO_AUTO_SWAP>|/"NO_AUTO_SWAP"> bit to the L<C<mode()>|/"mode">.

=head2 Overlays

The method L<C<draw_overlay()>|/"draw_overlay"> is a second drawing operation
that is put atop the main image. You can implement this, and call
L<C<redraw_overlay()>|/"redraw_overlay"> to indicate that the image in this
overlay has changed and that L<C<draw_overlay()>|/"draw_overlay"> must be
called.

Originally this was written to support hardware overlays, but FLTK emulated it
if the hardware was missing so programs were portable. FLTK 2.0 is not
normally compiled to support hardware overlays, but the emulation still
remains, so you can use these functions. (Modern hardware typically has no
overlays, and besides it is fast enough that the original purpose of them is
moot).

By default the emulation is to call L<C<draw_overlay()>|/"draw_overlay"> after
L<C<draw()>|/"draw"> and before swapping the buffers, so the overlay is just
part of the normal image and does not blink. You can get some of the
advantages of overlay hardware by setting the C<GL_SWAP_TYPE> environment
variable, which will cause the front buffer to be used for the
L<C<draw_overlay()>|/"draw_overlay"> method, and not call L<C<draw()>|/"draw">
each time the overlay changes. This will be faster if L<C<draw()>|/"draw"> is
very complex, but the overlay will blink. C<GL_SWAP_TYPE> can be set to:

=over 8

=item C<USE_COPY>
X<USE_COPY>
use glCopyPixels to copy the back buffer to the front. This should always
work.

=item C<COPY>
X<COPY>
indicates that the L<C<swap_buffers()>|/"swap_buffers"> function actually
copies the back to the front buffer, rather than swapping them. If your card
does this (most do) then this is best.

=item C<NODAMAGE>
X<NODAMAGE>
indicates that behavior is like L<C<COPY>|/"COPY"> but nothing changes the
back buffer, including overlapping it with another OpenGL window. This is true
of software OpenGL emulation, and may be true of some modern cards with lots
of memory.

=back

Inherits L<FLTK::Window|FLTK::Window>.

Inherited by L<FLTK::GlutWindow::FLTK::GlutWindow>.

=cut

=for apidoc g||FLTK::GlWindow|new|X|Y|W|H|LABEL = ""

Creates a new C<FLTK::GlWindow> object. Obviously.

The constructor sets the L<C<mode()>|/"mode"> to
C<RGB_COLOR|DEPTH_BUFFER|DOUBLE_BUFFER> which is probably all that is needed
for most 3D OpenGL graphics.

=cut

GlWindow *
GlWindow::new( x, y, w, h, label = 0 )
    int x
    int y
    int w
    int h
    char * label
    CODE:
        RETVAL = new GlWindow( x, y, w, h, label);
        RETVAL->copy_label( label );
        /* warn("%s|%s", RETVAL->label(), label); */
    OUTPUT:
        RETVAL

#if ALLOW_DESTROY

bool
GlWindow::DESTROY ( )
    CODE:
#if VERBOSE >= 2
        warn ( "Bye, GlWindow");
#endif
        delete THIS;
        RETVAL = true;
    OUTPUT:
        RETVAL

#endif


 # Public Member Functions

=for apidoc g||bool|can_do|

Returns C<true> if the hardware supports the current value of
L<C<mode()>|/"mode">. If C<false>, attempts to show or draw this window will
cause an L<C<FLTK::error()>|FLTK/"error">.

=cut

=for apidoc |g|bool|can_do|MODE

Returns C<true> if the hardware supports C<MODE>, see L<C<mode()>|/"mode"> for
the meaning of the bits.

=cut

bool
GlWindow::can_do ( MODE = NO_INIT )
    CASE: items == 2
        int MODE
        CODE:
            RETVAL = THIS->can_do( MODE );
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = THIS->can_do( );
        OUTPUT:
            RETVAL

=for apidoc ||bool|can_do_overlay|

Return C<true> if the hardware supports OpenGL overlay planes, and FLTK has
been compiled to use them. If C<true>, L<C<draw_overlay()>|/"draw_overlay">
will be called with OpenGL setup to draw these overlay planes, and
L<C<redraw_overlay()>|/"redraw_overlay"> will not cause the main
L<C<draw()>|/"draw"> to be called.

=cut

bool
GlWindow::can_do_overlay ( )


=for apidoc g|||context|FLTK::GLContext|destroy_flag = false

Set the OpenGL context object to use to draw this window.

This is a system-dependent structure (HGLRC on Windows, GLXContext on X, and
AGLContext (may change) on OS/X), but it is portable to copy the context from
one window to another. You can also set it to NULL, which will force FLTK to
recreate the context the next time L<C<make_current()>|/"make_current"> is
called, this is useful for getting around bugs in OpenGL implementations.

C<destroy_flag> indicates that the context belongs to this window and should
be destroyed by it when no longer needed. It will be destroyed when the window
is destroyed, or when the L<C<mode()>|/"mode"> is changed, or if the context
is changed to a new value with this call.

=cut

=for apidoc |g|FLTK::GLContext|context|

Return the curreng OpenGL context object being used by this window, or C<0> if
there is none.

=cut

fltk::GLContext
GlWindow::context ( V = NO_INIT, destroy_flag = false )
    CASE: items == 1
        CODE:
            RETVAL = THIS->context( );
        OUTPUT:
            RETVAL
    CASE:
        fltk::GLContext V
        bool            destroy_flag
        CODE:
            THIS->context( V, destroy_flag );

=for apidoc |||create|

NFI

=cut

void
GlWindow::create ( )

=for apidoc |||destroy|

NFI

=cut

void
GlWindow::destroy ( )

=for apidoc |||draw|

NFI

=cut

void
GlWindow::draw ( )

=for apidoc |||draw_overlay|

You must implement this virtual function if you want to draw into the overlay.
The overlay is cleared before this is called (unless the
C<NO_ERASE_OVERLAY|/"NO_ERAS_OVERLAY"> bit is set in the mode and hardware
overlay is supported). You should draw anything that is not clear using
OpenGL.

If the hardware overlay is being used it will probably be color indexed. You
must use L<C<glsetcolor()>|/"glsetcolor"> to choose colors (it allocates them
from the colormap using system-specific calls), and remember that you are in
an indexed OpenGL mode and drawing anything other than flat-shaded will
probably not work.

Depending on the OS and whether or not the overlay is being simulated, the
context may be shared with the main window. This means if you check
L<C<valid()>|/"valid"> in L<C<draw()>|/"draw"> to avoid initialization, you
must do so here and initialize to exactly the same setting.

Reimplemented from L<FLTK::Window|FLTK::Window>.

=cut

void
GlWindow::draw_overlay ( )


=for apidoc |||flush|

NFI

=cut

void
GlWindow::flush ( )

=for apidoc ||int|handle|EVENT

NFI

=cut

int
GlWindow::handle ( EVENT )
    int EVENT

=for apidoc |||hide_overlay|

NFI

=cut

void
GlWindow::hide_overlay ( )

=for apidoc |||invalidate|

Turn off L<C<valid()>|/"valid">.

=cut

void
GlWindow::invalidate ( )

=for apidoc |||layout|

NFI

=cut

void
GlWindow::layout ( )

=for apidoc |g||make_current|

Selects the OpenGL context for the widget, creating it if necessary. It is
called automatically prior to the L<C<draw()>|/"draw"> method being called.
You can call it in L<C<handle()>|/"handle"> to set things up to do OpenGL hit
detection, or call it other times to do incremental update of the window.

Reimplemented in L<FLTK::GlutWindow|FLTK::GlutWindow>.

=cut

void
GlWindow::make_current ( )

=for apidoc |g||make_overlay_current|

Selects the OpenGL context for the widget's overlay. This can be used to do
incremental OpenGL drawing into the overlay. If hardware overlay is not
supported, this sets things to draw into the front buffer, which is probably
not good enough emulation to be usable.

=cut

void
GlWindow::make_overlay_current ( )


=for apidoc |g|bool|mode|MODE

Set or change the OpenGL capabilites of the window. The value can be any of
the symbols from F<fltk/visual.h> C<OR>'d together:

=over 8

=item L<C<FLTK::INDEXED_COLOR>|FLTK/"INDEXED_COLOR">
indicates that a colormapped visual is ok. This call will normally fail if a
TrueColor visual cannot be found.

=item L<C<FLTK::RGB_COLOR>|FLTK/"RGB_COLOR">
this value is zero and may be passed to indicate that
L<C<FLTK::INDEXED_COLOR>|FLTK/"INDEXED_COLOR"> is not wanted.

=item L<C<FLTK::RGB24_COLOR>|FLTK/"RGB24_COLOR">
indicates that the visual must have at least C<8> bits of red, green, and blue
(Windows calls this "millions of colors").

=item L<C<FLTK::DOUBLE_BUFFER>|FLTK/"DOUBLE_BUFFERED">
indicates that double buffering is wanted.

=item L<C<FLTK::SINGLE_BUFFER>|FLTK/"SINGLE_BUFFERED">
is zero and can be used to indicate that double buffering is not wanted.

=item L<C<FLTK::ACCUM_BUFFER>|FLTK/"ACCUM_BUFFER">
makes the accumulation buffer work

=item L<C<FLTK::ALPHA_BUFFER>|FLTK/"ALPHA_BUFFER">
makes an alpha buffer

=item L<C<FLTK::DEPTH_BUFFER>|FLTK/"DEPTH_BUFFER">
makes a depth/Z buffer

=item L<C<FLTK::STENCIL_BUFFER>|FLTK/"STENCIL_BUFFER">
makes a stencil buffer

=item L<C<FLTK::MULTISAMPLE>|FLTK/"MULTISAMPLE">
makes it multi-sample antialias if possible (X only)

=item L<C<FLTK::STEREO>|FLTK/"STEREO">
stereo if possible

=item C<NO_AUTO_SWAP>
disables the automatic call to L<C<swap_buffers()>|/"swap_buffers" after
L<C<draw()>|/"draw">.

=item C<NO_ERASE_OVERLAY>
if overlay hardware is used, don't call glClear before calling
L<C<draw_overlay()>|/"draw_overlay">.

=back

If the desired combination cannot be done, FLTK will try turning off
L<C<MULTISAMPLE>|FLTK/"MULTISAMPLE"> and L<C<STEREO>|FLTK/"STEREO">. If this
also fails then attempts to create the context will cause
L<C<FLTK::error()>|FLTK/error> to be called, aborting the program. Use
L<C<can_do()>|/"can_do"> to check for this and try other combinations.

You can change the mode while the window is displayed. This is most useful for
turning double-buffering on and off. Under X this will cause the old X window
to be destroyed and a new one to be created. If this is a top-level window
this will unfortunately also cause the window to blink, raise to the top, and
be de-iconized, and the ID will change, possibly breaking other code. It is
best to make the GL window a child of another window if you wish to do this!

=cut

=for apidoc |g|int|mode|

NFI

=cut

int
GlWindow::mode ( MODE = NO_INIT )
    CASE: items == 2
        int MODE
    CASE:
        CODE:
            RETVAL = THIS->mode( );
    OUTPUT:
        RETVAL

=for apidoc |g||ortho|

Set the projection so C<0,0> is in the lower left of the window and each pixel
is C<1> unit wide/tall. If you are drawing C<2D> images, your
L<C<draw()>|/"draw"> method may want to call this when L<C<valid()>|/"valid">
is C<false>.

=cut

void
GlWindow::ortho ( )

=for apidoc |g||redraw_overlay|

Causes L<C<draw_overlay()>|/"draw_overlay"> to be called at a later time.
Initially the overlay is clear, if you want the window to display something in
the overlay when it first appears, you must call this immediately after you
L<C<show()>|/"show"> your window.

Reimplemented from L<FLTK::Window|FLTK::Window>.

=cut

void
GlWindow::redraw_overlay ( )

=for apidoc |g||swap_buffers|

Swap the front and back buffers of this window (or copy the back buffer to the
front, possibly clearing or garbaging the back one, depending on your OpenGL
implementation.

This is called automatically after L<C<draw()>|/"draw"> unless the
L<C<NO_AUTO_SWAP>|/"NO_AUTO_SWAP"> flag is set in the L<C<mode()>|/"mode">.

=cut

void
GlWindow::swap_buffers ( )

=for apidoc |g|char|valid|

This flag is turned off on a new window or if the window is ever resized or
the context is changed. It is turned on after L<C<draw()>|/"draw"> is called.
L<C<draw()>|/"draw"> can use this to skip initializing the viewport, lights,
or other pieces of the context.

 {
    package My::GlWindow::Subclass;
    # ...

    sub draw {
        my ( $self ) = @_;
        if ( ! $self->valid( ) ) {
            $self->glViewport( 0, 0, $self->w( ), $self->h( ) );
            $self->glFrustum( ... );
            $self->glLight( ... );
            $self->glEnable( ... );
            # ...other initialization...
        }
        # ... draw your geometry here ...
    }

    # ...
 }

=cut

=for apidoc |g||valid|char

NFI

=cut

char
GlWindow::valid ( CHAR = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->valid( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        char CHAR
        CODE:
            THIS->valid( CHAR );

=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut

#endif
