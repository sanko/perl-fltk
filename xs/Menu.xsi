MODULE = FLTK               PACKAGE = FLTK::Menu

=pod

=head1 Description

The L<Menu|FLTK::Menu> base class is used by L<Browser|FLTK::Browser>,
L<Choice|FLTK::Choice>, L<MenuBar|FLTK::MenuBar>,
L<PopupMenu|FLTK::PopupMenu>, L<ComboBox|FLTK::ComboBox>, and other widgets.
It is simply a L<Group|FLTK::Group> and each item is a child
L<Widget|FLTK::Widet>, but it provides functions to select and identify one of
the widgets in the hierarchy below it and do that widget's callback directly,
and functions to create and add L<Item|FLTK::Item> and
L<ItemGroup|FLTK::ItemGroup> widgets to a hierarchy.

A L<Menu|FLTK::Menu> can take a pointer to a L<List|FLTK::List> object, which
allows the user program to dynamically provide the items as they are needed.
This is much easier than trying to maintain an array of
L<Widgets|FLTK::Widget> in parallel with your own data structures.

It also provides several convienence functions for creating, rearranging, and
deleting child L<Item|FLTK::Item> and L<ItemGroup|FLTK::ItemGroup> widgets.

Inherits L<FLTK::Group|FLTK::Group>.

Inherited by L<FLTK::Browser|FLTK::Browser>, L<FLTK::Choice|FLTK::Choice>,
L<FLTK::CycleButton|FLTK::CycleButton>,
L<FLTK::InputBrowser|FLTK::InputBrowser>, L<FLTK::ItemGroup|FLTK::ItemGroup>,
L<FLTK::MenuBar|FLTK::MenuBar>, and L<FLTK::PopupMenu|FLTK::PopupMenu>.

=cut

#include <fltk/Menu.h>


=for apidoc H||FLTK::Menu|new|X|Y|WIDTH|HEIGHT|LABEL|BEGIN = false

Creates a new object.

=cut

fltk::Menu *
fltk::Menu::new ( X, Y, WIDTH, HEIGHT, LABEL = 0, BEGIN = false )
    int X
    int Y
    int WIDTH
    int HEIGHT
    const char         * LABEL
    bool BEGIN
    CODE:
        RETVAL = new fltk::Menu( X, Y, WIDTH, HEIGHT, LABEL, BEGIN );
        RETVAL->copy_label( LABEL );
    OUTPUT:
        RETVAL

#if ALLOW_DESTROY

bool
fltk::List::DESTROY ( )
    CODE:
#if VERBOSE >= 2
        warn ( "Bye, List" );
#endif
        delete THIS;
        RETVAL = true;
    OUTPUT:
        RETVAL

#endif

=for apidoc ||FLTK::Widget|add|WIDGET

NFI

=cut

=for apidoc H||FLTK::Widget|add|LABEL|DATA = 0

Create a new L<Item|FLTK::Item> and add it to the top-level of the hierarchy.

This matches L<C<add()>|/"add"> from the L<Browser|FLTK::Browser> in fltk1.

Unlike the L<C<add()>|/"add"> with more arguments, this one does B<not> split
the label at C</> characters. The label is used unchanged.

=cut

=for apidoc H||FLTK::Widget|add|LABEL|SHORTCUT|CALLBACK|DATA = 0|FLAGS = 0

Split label at C</> characters and add a hierachial L<Item|FLTK::Item>.

Adds new items and hierarchy to a L<Menu|FLTK::Menu> or
L<Browser|FLTK::Browser>.

=over 8

=item C<LABEL>

The label is split at C</> characters to automatically produce submenus. The
submenus are created if they do not exist yet, and a new L<Item|FLTK::Item>
widget is added to the end of it.

A trailing C</> can be used to create an empty submenu (useful for forcing a
certain ordering of menus before you know what items are in them).

Backslashes in the string "quote" the next character, which allows you to put
forward slashes into a menu item. Notice that in C++ you must type C<\\/> for
a forward slash, and C<\\\\> for a backward slash.

=item C<SHORTCUT>

C<0> for no shortcut, C<L<FLTK::CTRL|FLTK/"CTRL">|'a'> for C<ctrl-a>, etc.

=item C<CALLBACK>

function to call when item picked. If C<null>, the callback for the
L<Menu|FLTK::Menu> widget itself is called.

=item C<DATA>

second argument passed to the callback.

=cut C<FLAGS>

useful flags are:

=over 8

=item C<INACTIVE>
makes the item grayed out and unpickable

=item C<INVISIBLE>
makes it not visible to the user, as though it was not there. This is most useful for making extra shortcuts that do the same thing.

=item C<RAW_LABEL>
stops it from interpreting C<&> and C<@> characters in the label.

=back

=back

Returns a pointer to the new L<Item|FLTK::Item>. You can further modify it to
get results that can't be gotten from these function arguments.

=cut

fltk::Widget *
fltk::Menu::add ( A, B = NO_INIT, CALLBACK = NO_INIT, DATA = 0, FLAGS = 0 )
    CASE: ( sv_isobject( ST(1) ) )
        fltk::Widget * A
        CODE:
            THIS->add( A );
    CASE: ( items == 2) || ( items == 3 )
        char * A
        char * B
        CODE:
            RETVAL = THIS->add( A, B );
            RETVAL->copy_label( A );
        OUTPUT:
            RETVAL
    CASE:
        char   * A
        unsigned B
        int      FLAGS
        CODE:
            AV *arr = newAV();
            av_store(arr, 0, newSVsv((SV*)ST(3))); // coderef
            av_store(arr, 0, newSVsv((SV*)ST(4))); // 2nd arg to callback
            RETVAL = THIS->add( A, B, cb_w, arr, FLAGS );
            RETVAL->copy_label( A );
        OUTPUT:
            RETVAL

=for apidoc ||FLTK::Group|add_group|LABEL|PARENT = 0|DATA = 0

Add a parent widget to a (possibly) lower level of the hierarchy, suah as
returned by L<C<add_group()>|/"add_group">.

=cut

fltk::Group *
fltk::Menu::add_group ( LABEL, PARENT, DATA )
    const char  * LABEL
    fltk::Group * PARENT
          char  * DATA

=for apidoc ||FLTK::Widget|add_leaf|LABEL|PARENT = 0|DATA = 0

Add a non-parent widget to a (possibly) lower level of the hierarchy, such as
returned by L<add_group()|/"add_group">. If parent is null or this then this
is the same as L<add(label,data)|/"add">.

=cut

fltk::Widget *
fltk::Menu::add_leaf ( LABEL, PARENT, DATA )
    const char  * LABEL
    fltk::Group * PARENT
          char  * DATA

=for apidoc ||FLTK::Widget|add_many|STRING

This is a Forms (and SGI GL library) compatable add function, it adds many
menu items, with C<|> seperating the menu items, and C<\t> seperating the menu
item names from an optional shortcut string.

=cut

fltk::Widget *
fltk::Menu::add_many ( STRING )
    const char * STRING

=for apidoc  ||FLTK::Widget|child|INDEX

Returns the given top-level child. Same as L<C<child(&INDEX, 0)>|/"child">.

I<This Overrides the method of the same name on L<FLTK::Group|FLTK::Group>.
This is so that an L<FLTK::List|FLTK::List> can be used. However if no
L<FLTK::List|FLTK::List> is specified the action is identical to
L<C<FLTK::Group::child(INDEX)>|FLTK::Group/"child">.

Reimplemented from L<FLTK::Group|FLTK::Group>.

=cut

=for apidoc ||FLTK::Widget|child|INDEXES|LEVEL

Calls C<list()->child($self, INDEXES, LEVEL)>. If an L<FLTK::List|FLTK::List>
is used, the returned widget may be a temporary data structure and may be
overwritten by another call to L<C<child()>|/"child"> in this I<or any other
L<Menu|FLTK::Menu>>!

=cut

fltk::Widget *
fltk::Menu::child ( INDEX, LEVEL = NO_INIT )
    CASE: items == 2
        int INDEX
        C_ARGS: INDEX
    CASE:
        AV * INDEX
        int  LEVEL
        CODE:
            int * REAL_INDEXES;
            for ( int i = 0; i < av_len(INDEX); i++ )
                REAL_INDEXES[i] = (int)(av_fetch(INDEX, i, 0));
            RETVAL = THIS->child( ( const int * ) REAL_INDEXES, LEVEL );
        OUTPUT:
            RETVAL

=for apidoc ||int|children|

Returns the number of children at the top level. Same as C<children(0,0)>.

I<This Overrides the method of the same name on L<FLTK::Group|FLTK::Group>.
This is so that an L<FLTK::List|FLTK::List> can be used. However if no
L<FLTK::List|FLTK::List> is specified the action is identical to
L<C<FLTK::Group::children()>|FLTK::Group/"children">.

Reimplemented from L<FLTK::Group|FLTK::Group>.

=cut

=for apidoc ||int|children|INDEX

Returns the number of children of some child. Same as L<children( INDEX, 1)>.

=cut

=for apidoc ||int|children|INDEXES|LEVEL

Calls lC<ist()->children($self, INDEXES, LEVEL)>

=cut

int
fltk::Menu::children ( INDEX = NO_INIT, LEVEL = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->children( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        int INDEX
        C_ARGS: INDEX
    CASE:
        AV * INDEX
        int  LEVEL
        CODE:
            int * REAL_INDEXES;
            for ( int i = 0; i < av_len(INDEX); i++ )
                REAL_INDEXES[i] = (int)(av_fetch(INDEX, i, 0));
            RETVAL = THIS->children( ( const int * ) REAL_INDEXES, LEVEL );
        OUTPUT:
            RETVAL

=for apidoc |||draw_in|WIDGET|INDEXES|LEVEL|SELECTED|DRAWN_SELECTED

Draw the menu items inside the widget.

The widget's L<C<box()|FLTK::Widget/"box"> is drawn and the items are laid out
exactly the same as for L<C<layout()>|/"layout">.

If selected is greater or equal to zero then that item is drawn in a selected
manner.

If C<widget->L<damage()|/"damage">==DAMAGE_CHILD> then it is assummed that
only the items indicated by C<SELECTED> and C<DRAWN_SELECTED> need to be
redrawn. This is used for minimal update to move the selection from one item
to the next.

=cut

void
fltk::Menu::draw_in ( WIDGET, INDEXES, LEVEL, SELECTED, DRAWN_SELECTED )
    fltk::Widget * WIDGET
    AV           * INDEXES
    int            LEVEL
    int            SELECTED
    int            DRAWN_SELECTED
    CODE:
        int * REAL_INDEXES;
        for ( int i = 0; i < av_len(INDEXES); i++ )
            REAL_INDEXES[i] = (int)(av_fetch(INDEXES, i, 0));
        THIS->draw_in(
            WIDGET, ( const int * ) REAL_INDEXES, LEVEL, SELECTED,
            DRAWN_SELECTED
        );

=for apidoc |||execute|WIDGET

Calls L<C<do_callback()>|FLTK::Widget/"do_callback">. First it sets L<C<item()>|/"item">
to the given widget, so the callback code can see it.

Notice that this calls the callback on the L<Menu|FLTK::Menu> widget itself,
not on the menu item. However the default callback for L<Menu|FLTK::Menu>
widget does
C<L<item()|/"item">>-E<gt>L<do_callback()|FLTK::Widget/"do_callback">> so by
default the callback for each menu item is done.

Callbacks for items can be disabled, so
C<L<item()|/"item">-E<gt>when(WHEN_NEVER)> will disable it for named item, but
calling C<when(WHEN_NEVER)> with menu instance will disable callbacks for all
menu items (but not for the menu itself).

=cut

void
fltk::Menu::execute ( WIDGET )
    fltk::Widget * WIDGET

=for apidoc ||FLTK::Widget|find|LABEL

Return the item with the given C<LABEL>.

This searches both the top level for an exact match, and splits the label at
C</> to find an item in a hierarchy. Thus it matches the strings passed to
both the long and short forms of L<C<add()>|/"add">.

If the item is found, a pointer to it is returned, otherwise C<NULL> is
returned.

=cut

fltk::Widget *
fltk::Menu::find ( LABEL )
    const char * LABEL

=for apidoc ||int|find_selected|WIDGET|INDEXES|LEVEL|MX|MY

Return the index of the item that is under the location C<MX, MY> in the given
C<WIDGET>, if the L<C<draw()>|/"draw"> method had been used to draw the items
into the widget.

=cut

int
fltk::Menu::find_selected ( WIDGET, INDEXES, LEVEL, MX, MY )
    fltk::Widget * WIDGET
    AV           * INDEXES
    int            LEVEL
    int            MX
    int            MY
    CODE:
        int * REAL_INDEXES;
        for ( int i = 0; i < av_len(INDEXES); i++ )
            REAL_INDEXES[i] = (int)(av_fetch(INDEXES, i, 0));
        RETVAL = THIS->find_selected(
            WIDGET, ( const int * ) REAL_INDEXES, LEVEL, MX, MY
        );
    OUTPUT:
        RETVAL

=for apidoc ||FLTK::Widget|get_item|

Sets and returns L<C<item()>|/"item"> based on the
L<C<focus_index()>|/"focus_index"> in this and each child group, thus
restoring the value saved with L<C<set_item()>|/"set_item">.

This either returns a non-group node, or child group that has an illegal
L<C<Group::focus_index()>|FLTK::Group/"focus_index">, or null if this
L<C<focus_index()>|/"focus_index"> is illegal.

If an L<FLTK::List|FLTK::List> is used this will probably only go to the first
child and not descend any further.

=cut

fltk::Widget *
fltk::Menu::get_item ( )

=for apidoc ||FLTK::Rectangle|get_location|WIDGET|INDEXES|LEVEL|INDEX

Return the bounding box of the given item inside the widget, if the
L<C<draw()>|/"draw"> method had been used to draw the items into the widget.

=cut

fltk::Rectangle
fltk::Menu::get_location ( WIDGET, INDEXES, LEVEL, INDEX )
    fltk::Widget * WIDGET
    AV           * INDEXES
    int            LEVEL
    int            INDEX
    CODE:
        int * REAL_INDEXES;
        for ( int i = 0; i < av_len(INDEXES); i++ )
            REAL_INDEXES[i] = (int)(av_fetch(INDEXES, i, 0));
        RETVAL = THIS->get_location(
            WIDGET, ( const int * ) REAL_INDEXES, LEVEL, INDEX
        );
    OUTPUT:
        RETVAL

=for apidoc |||global|

Make the shortcuts for this menu work no matter what window has the focus when
you type it (as long as L<C<FLTK::modal()>|FLTK/"modal"> is off). This is done
by using L<C<FLTK::add_handler()>|FLTK/"add_handler">. This
L<FLTK::Menu|FLTK::Menu> widget does not have to be visible (ie the window it
is in can be hidden, or it does not have to be put in a window at all).

Currently there can be only one L<C<global()>|/"global"> menu. Setting a new
one will replace the old one. There is no way to remove the
L<C<global()>|/"global"> setting, and you cannot destroy the
L<Menu|FLTK::Menu>!

This should probably also put the items on the the Mac menubar.

=cut

void
fltk::Menu::global ( )

=for apidoc ||int|handle_shortcut|

Respond to the current L<C<FLTK::SHORTCUT>|FLTK/"SHORTCUT"> or
L<C<FLTK::KEY>|FLTK/"KEY"> event by finding a menu item it matches and calling
L<C<execute()>|/"execute"> on it. C<true> is returned if a menu item is found,
C<false> if none. L<Items|FLTK::Item> are searched for a matching
L<C<shortcut()>|FLTK::Widget/"shortcut"> value. C<&x> shortcuts are ignored,
they are used only for navigating when the menu is visible.

If you use a L<List|FLTK::List>, only the top-most level items are searched
for shortcuts. Recursion is done only if the children are L<Group|FLTK::Group>
widgets, and then only the actual children of that L<Group|FLTK::Group> (not
any List it may contain if it is another L<Menu|FLTK::Menu>) are searched.
This is necessary because some L<Lists|FLTK::List> are infinite in size, and
usually they don't have shortcuts anyway.

This will return invisible (but active) items, even though it is impossible to
select these items with the gui. This is done so that more than one shortcut
for an action may be given by putting multiple copies of the item in, where
only the first is visible.

=cut

int
fltk::Menu::handle_shortcut ( )

=for apidoc H|||insert|WIDGET|INDEX

NFI

=cut

=for apidoc ||FLTK::Widget|insert|INDEX|LABEL|DATA = 0

Create a new L<Item|FLTK::Item> and add it to the top-level of the hierarchy.

This matches L<C<insert()>|/"insert"> from the L<Browser|FLTK::Browser> in
fltk1, except the C<INDEX> is C<1> less than before (first item is zero, not
C<1>).

Unlike the L<C<insert()>|/"insert"> with more arguments, this one does *not*
split the label at C</> characters. The label is used unchanged.

=cut

=for apidoc ||FLTK::Widget|insert|INDEX|LABEL|SHORTCUT|CALLBACK|DATA = 0|FLAGS = 0

Split label at C</> characters and add a hierachial L<Item|FLTK::Item>.

Same rules as L<C<add()>|/"add"> except the item is inserted at C<INDEX> of
the final menu. Use C<0> to put it at the start. Any number larger or equal to
the current item count adds the new item to the end.

=cut

fltk::Widget *
fltk::Menu::insert ( ALPHA, BETA = NO_INIT, GAMMA = NO_INIT, DELTA = NO_INIT, EPSILON = NO_INIT, ZETA = NO_INIT )
    #CASE: ( items == 2 ) && ( sv_isobject( ST(1) )  ) && ( SvIOK( ST(2) ) )
    #    fltk::Widget * ALPHA
    #    int            BETA
    #    CODE:
    #        THIS->insert( ALPHA, BETA );
    CASE: ( items >= 3)
        int          ALPHA
        const char * BETA
        char       * GAMMA
        C_ARGS: ALPHA, BETA, GAMMA
    CASE:
        int              ALPHA
        const char     * BETA
        unsigned         GAMMA
        fltk::Callback * DELTA
        char           * EPSILON
        int              ZETA
        C_ARGS: ALPHA, BETA, GAMMA, DELTA, EPSILON, ZETA

=for apidoc ||FLTK::Widget|item|WIDGET

You can set L<C<item()>|/"item"> with the second call, useful for outwitting
the callback. This does not produce any visible change for the user.

=cut

=for apidoc ||FLTK::Widget|item|

The "current item". In callbacks this is the item the user clicked on.
Otherwise you probably can't make any assumptions about it's value.

L<C<Browser::goto_index()>|FLTK::Browser/"goto_index"> sets this to the
current item.

Since this may be the result of calling L<C<child()>|/"child"> the returned
structure may be short-lived if an L<FLTK::List|FLTK::List> is used.

=cut

fltk::Widget *
fltk::Menu::item ( WIDGET = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->item ( );
        OUTPUT:
            RETVAL
    CASE:
        fltk::Widget * WIDGET

=for apidoc |||layout|

Does nothing. This avoids wasting time measuring all the menu items.

Reimplemented from L<FLTK::Group|FLTK::Group/"layout">.

=cut

void
fltk::Menu::layout ( )

=for apidoc |||layout_in|WIDGET|INDEXES|LEVEL

Resize the widget to contain the menu items that are the children of the item
indicated by C<INDEXES> and C<LEVEL> (use C<0> for the immediate children).

If the widget has L<C<vertical()>|FLTK::Widget/"vertical"> C<true>, the menu
items are laid out one above the other, as is usally done in the pull-down
menu below a menubar. L<C<w()>|FLTK::Rectangle/"w"> is set to the widest item,
and L<C<h()>|FLTK::Rectangle/"h"> to the sum of all the heights.

If the widget has L<C<horizontal()>|FLTK::Widget/"horizontal"> C<true> then
the items are laid out in rows, wrapping only when
L<C<w()>|FLTK::Rectangle/"w"> is exceeded. L<C<w()>|FLTK::Rectangle/"w"> is
changed only if it is too small to contain the smallest item.
L<C<h()>|FLTK::Rectangle/"h"> is set to the total height of all the rows.

The L<C<box()>|/"box">, L<C<leading()>|/"leading">,
L<C<textfont()>|/"textfont">, L<C<textsize()>|/"textsize">, and perhaps other
style attributes of the widget are used when figuring out the total size and
the size of each item.

=cut

void
fltk::Menu::layout_in ( WIDGET, INDEXES, LEVEL )
    fltk::Widget * WIDGET
    AV           * INDEXES
    int            LEVEL
    CODE:
        int * REAL_INDEXES;
        for ( int i = 0; i < av_len(INDEXES); i++ )
            REAL_INDEXES[i] = (int)(av_fetch(INDEXES, i, 0));
        THIS->layout_in( WIDGET, ( const int * ) REAL_INDEXES, LEVEL );

=for apidoc |||list|LIST

Set the L<List|FLTK::List> that generates widgets for the menu. By default
this is a dummy L<List|FLTK::List> that returns the child widgets of the
L<Menu|FLTK::Menu>.

=cut

=for apidoc ||FLTK::List|list|

Returns the L<List|FLTK::List> that generates widgets for the menu.

=cut

fltk::List *
fltk::Menu::list ( LIST = NO_INIT )
    CASE: items == 2
        fltk::List * LIST
        CODE:
            THIS->list( LIST );
    CASE: items == 1
        CODE:
            RETVAL = THIS->list( );
        OUTPUT:
            RETVAL

=for apidoc ||int|popup|RECT|TITLE = 0|MENUBAR = false

Create and display a pop-up menu (or hierarchy of menus) showing the children
of this L<Menu|FLTK::Menu>, then wait until the user picks an item or
dismisses the menu. If the user picks an item then L<C<execute()>|/"execute">
is called for it and C<true> is returned. C<false> is returned if the user
cancels the menu.

If there is a selected item in the menu (as determined by
L<C<get_item()>|/"get_item">) then submenus are opened and all of them are
positioned intitially so the mouse cursor is pointing at the selected item.
This is incredibly useful and one of the main features of fltk that is missing
from other toolkits.

C<x,y,w,h> describe a rectangle that the current menu item should be centered
over, and the menu is widened horizontally to w if it is narrower. The
coordinates are measured relative to the widget whose L<C<handle()>|/"handle">
method is being executed now.

C<TITLE> is a widget (usually an L<FLTK::Item|FLTK::Item>) that is used to
make a title atop the menu, in the style of SGI's popup menus. You cannot use
a L<List|FLTK::List> child, as the drawing of the menu may navigate that list
to other children, overwriting the original widget.

C<MENUBAR> is for internal use by menubars and should be left C<false>.

=cut

int
fltk::Menu::popup ( RECT, TITLE = 0, MENUBAR = false )
    fltk::Rectangle * RECT
    const char      * TITLE
    bool              MENUBAR
    C_ARGS: ( const fltk::Rectangle & ) RECT, TITLE, MENUBAR

=for apidoc |||remove|WIDGET

Deletes the C<WIDGET>.

=cut

=for apidoc |||remove|INDEX

Does L<C<find(INDEX)>|/"find"> and then deletes that widget.

=cut

=for apidoc |||remove|LABEL

Removes the widget with this C<LABEL>.

=cut

void
fltk::Menu::remove ( WIDGET )
    CASE: sv_isobject( ST(1) )
        fltk::Widget * WIDGET
    CASE: SvIOK( ST(1) )
        int WIDGET
    CASE:
        const char * WIDGET

=for apidoc |||replace|WIDGET1|WIDGET2

NFI

=cut

=for apidoc H|||replace|INDEX|WIDGET

NFI

=cut

=for apidoc ||FLTK::Widget|replace|LABEL|BLAH = 0

Create or replace an L<Item|FLTK::Item> at the top-level of the hierarchy.

The top level is searched for an item that matches the given label. If found,
it's data is changed to the passed data, if not found a new L<Item|FLTK::Item>
is created and added at the end.

=cut

=for apidoc ||FLTK::Widget|replace|LABEL|

Split label at C</> characters and add or replace a hierachial
L<Item|FLTK::Item>.

This is what L<C<FLTK::Menu::add()>|/"add"> did in fltk 1.

Same rules as L<C<add()>|/"add"> except if the item already exists it is
changed to this new data, instead of a second item with the same label being
created.

If the C<LABEL> has any C<@> or C<&> commands in any portion, that portion is
relabelled, thus you can use this to change the appearance of existing menu
items. However if the new label does not have any such commands, the label
remains as before, with any older C<@>-commands.

=cut

fltk::Widget *
fltk::Menu::replace ( A, B = NO_INIT, C = NO_INIT, D = NO_INIT, E = NO_INIT )
    CASE: ( items == 2 ) && ( sv_isobject( ST(1) ) ) && ( sv_isobject( ST(2) ) )
        fltk::Widget * A
        fltk::Widget * B
        CODE:
            THIS->replace( ( fltk::Widget & ) A, ( fltk::Widget & ) B );
    #CASE: ( items == 2 ) && ( SvIOK(1) ) && ( sv_isobject( ST(2) ) )
    #    int           A
    #    fltk::Widget * B
    #    CODE:
    #        THIS->replace( A, ( fltk::Widget & ) B );
    CASE: ( ( items == 2 ) || ( items == 3 ) ) && ( SvPOK( ST(1) ) )
        const char * A
              char * B
        C_ARGS: A, B
    CASE: ( items >= 4 )
        const char     * A
        unsigned         B
        fltk::Callback * C
        char           * D
        int              E
        C_ARGS: A, B, C, D, E

=for apidoc ||bool|set_item|INDEXES|LEVEL

Remembers a currently selected item in a hierarchy by setting the
L<C<focus_index()>|FLTK::Group/"focus_index"> of each group to point to the
next one. The widget can then be recovered with L<C<get_item()>|/"get_item">.
A rC<edraw(DAMAGE_VALUE)> is done so pulldown menus redraw their display.

=cut

bool
fltk::Menu::set_item ( INDEXES, LEVEL )
    AV * INDEXES
    int  LEVEL
    CODE:
        int * REAL_INDEXES;
        for ( int i = 0; i < av_len(INDEXES); i++ )
            REAL_INDEXES[i] = (int)(av_fetch(INDEXES, i, 0));
        THIS->set_item( ( const int * ) REAL_INDEXES, LEVEL );

=for apidoc d||int|size|

Returns L<C<children()>|/"children"> (for back compatability with older
versions of fltk).

=cut

int
fltk::Menu::size ( )

=for apidoc ||bool|value|VALUE

Convienence function to do L<C<set_item()>|/"set_item"> when there is only one
level of hierarchy. In this case you can consider the menu items to be indexes
starting at zero.

Reimplemented in L<FLTK::Browser|FLTK::Browser>.

=cut

=for apidoc ||int|value|

NFI

=cut

int
fltk::Menu::value ( VALUE = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->value( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        int VALUE
        C_ARGS: VALUE

 #  Static Public Member Functions

=for apidoc |||default_callback|WIDGET|CODEREF

The default callback for L<Menu|FLTK::Menu> calls
C<L<item()|/"item">-E<gt>L<do_callback()|FLTK::Widget/"do_callback">> but if
L<C<user_data()>|FLTK::Widget/"user_data"> is not null it is used instead of
the item's L<C<user_data()>|FLTK::Item/"user_data">.

Reimplemented from L<FLTK::Widget|FLTK::Widget>.

=cut

void
fltk::Menu::default_callback ( WIDGET, CODEREF )
    fltk::Widget * WIDGET
    void * CODEREF
    CODE:
        AV * arr;
        av_store(arr, 0, newSVsv((SV*)ST(3))); // coderef
        WIDGET->user_data( arr );
        THIS->default_callback( WIDGET, cb_w );

 # Static Public Attributes

=for apidoc d||FLTK::NamedStyle|default_style|

TODO

=cut

fltk::NamedStyle *
fltk::Menu::default_style ( )
    CODE:
        RETVAL = THIS->default_style;
    OUTPUT:
        RETVAL

=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut
