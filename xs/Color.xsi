#ifndef DISABLE_COLOR

MODULE = FLTK               PACKAGE = FLTK::Color

=pod

=for license Artistic License 2.0 | Copyright (C) 2009 by Sanko Robinson

=for author Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

=for abstract Color value

=for git $Id$ for got=

=head1 Description

L<FLTK::Color|FLTK::Color> is a typedef for a 32-bit integer containing r,g,b
bytes and an "index" in the lowest byte (the I<first> byte on a
little-endian machine such as an x86).  For instance C<0xFF008000> is 255 red,
zero green, and 128 blue. If rgb are not zero then the low byte is ignored, or
may be treated as "alpha" by some code.

If the rgb is zero, the N is the color "index". This index is used to look up
an L<FLTK::Color|FLTK::Color> in an internal table of 255 colors shown here.
All the indexed colors may be changed by using
L<C<set_color_index()>|/"set_color_index">.  However FLTK uses the ones
between 32 and 255 and assummes they are not changed from their default
values.

A Color of zero (L<C<FLTK::NO_COLOR>|FLTK::Color/"NO_COLOR">) will draw black
but is ambiguous. It is returned as an error value or to indicate portions of
a L<Style|FLTK::Style> that should be inherited, and it is also used as the
default label color for everything so that changing color zero can be used by
the C<-fg> switch. You should use L<C<FLTK::BLACK>|FLTK::Color/"BLACK"> (56)
to get black.

=head1 Functions

Symbolic names for some of the indexed colors.

The 24-entry "gray ramp" is modified by
L<C<FLTK::set_background()>|FLTK/"set_background"> so that the color
C<FLTK::GRAY75> is the background color, and the others are a nice range from
black to a lighter version of the gray. These are used to draw box edges. The
gray levels are chosen to be evenly spaced, listed here is the actual 8-bit
and decimal gray level assigned by default.  Also listed here is the letter
used for L<FLTK::FrameBox|FLTK::FrameBox> and the old fltk1.1 names used for
these levels.

The remiander of the colormap is a C<5x8x5> color cube. This cube is used to
dither images on 8-bit screens X colormaps to reduce the number of colors
used.

=cut

#include <fltk/Color.h>

=for apidoc t[color]Ue||int|NO_COLOR|

Black, empty place holder in Style

=for apidoc t[color]Ue||int|FREE_COLOR|

Starting from index 16 is the FREE_COLOR area

=for apidoc t[color]Ue||int|NUM_FREE_COLOR|

Number of free color slots starting from index FREE_COLOR

=for apidoc t[color]Ue||int|GRAY00|

hex=00, dec=.00, framebox=A, fltk1 = GRAY0, GRAY_RAMP

=for apidoc t[color]Ue||int|GRAY05|

hex=0d, dec=.05, framebox=B

=for apidoc t[color]Ue||int|GRAY10|

hex=1a, dec=.10, framebox=C

=for apidoc t[color]Ue||int|GRAY15|

hex=27, dec=.15, framebox=D

=for apidoc t[color]Ue||int|GRAY20|

hex=34, dec=.20, framebox=E

=for apidoc t[color]Ue||int|GRAY25|

hex=41, dec=.25, framebox=F

=for apidoc t[color]Ue||int|GRAY30|

hex=4f, dec=.31, framebox=G

=for apidoc t[color]Ue||int|GRAY33|

hex=5c, dec=.36, framebox=H, fltk1 = DARK3

=for apidoc t[color]Ue||int|GRAY35|

hex=69, dec=.41, framebox=I

=for apidoc t[color]Ue||int|GRAY40|

hex=76, dec=.46, framebox=J (18%% gray card)

=for apidoc t[color]Ue||int|GRAY45|

hex=83, dec=.51, framebox=K

=for apidoc t[color]Ue||int|GRAY50|

hex=90, dec=.56, framebox=L

=for apidoc t[color]Ue||int|GRAY55|

hex=9e, dec=.62, framebox=M

=for apidoc t[color]Ue||int|GRAY60|

hex=ab, dec=.67, framebox=N, fltk1 = DARK2

=for apidoc t[color]Ue||int|GRAY65|

hex=b8, dec=.72, framebox=O

=for apidoc t[color]Ue||int|GRAY66|

hex=c5, dec=.77, framebox=P, fltk1 = DARK1, INACTIVE_COLOR

=for apidoc t[color]Ue||int|GRAY70|

hex=d2, dec=.82, framebox=Q

=for apidoc t[color]Ue||int|GRAY75|

hex=e0, dec=.88, framebox=R, fltk1 = GRAY, SELECTION_COLOR

=for apidoc t[color]Ue||int|GRAY80|

hex=e5, dec=.90, framebox=S

=for apidoc t[color]Ue||int|GRAY85|

hex=ea, dec=.92, framebox=T, fltk1 = LIGHT1

=for apidoc t[color]Ue||int|GRAY90|

hex=f4, dec=.96, framebox=V, fltk1 = LIGHT2

=for apidoc t[color]Ue||int|GRAY95|

hex=f9, dec=.98, framebox=W

=for apidoc t[color]Ue||int|GRAY99|

hex=ff, dec=1.0, framebox=X, fltk1 = LIGHT3

=for apidoc t[color]Ue||int|BLACK|

Corner of color cube

=for apidoc t[color]Ue||int|RED|

Corner of color cube

=for apidoc t[color]Ue||int|GREEN|

Corner of color cube

=for apidoc t[color]Ue||int|YELLOW|

Corner of color cube

=for apidoc t[color]Ue||int|BLUE|

Corner of color cube

=for apidoc t[color]Ue||int|MAGENTA|

Corner of color cube

=for apidoc t[color]Ue||int|CYAN|

Corner of color cube

=for apidoc t[color]Ue||int|WHITE|

Corner of color cube

=for apidoc t[color]Ue||int|DARK_RED|



=for apidoc t[color]Ue||int|DARK_GREEN|



=for apidoc t[color]Ue||int|DARK_YELLOW|



=for apidoc t[color]Ue||int|DARK_BLUE|



=for apidoc t[color]Ue||int|DARK_MAGENTA|



=for apidoc t[color]Ue||int|DARK_CYAN|



=for apidoc t[color]Ue||int|WINDOWS_BLUE|

Default selection_color

=cut

BOOT:
    newCONSTSUB(FLTK_stash, "NO_COLOR", newSViv( NO_COLOR ));
    export_tag("NO_COLOR", "color");
    newCONSTSUB(FLTK_stash, "FREE_COLOR", newSViv( FREE_COLOR ));
    export_tag("FREE_COLOR", "color");
    newCONSTSUB(FLTK_stash, "NUM_FREE_COLOR", newSViv( NUM_FREE_COLOR ));
    export_tag("NUM_FREE_COLOR", "color");
    newCONSTSUB(FLTK_stash, "GRAY00", newSViv( GRAY00 ));
    export_tag("GRAY00", "color");
    newCONSTSUB(FLTK_stash, "GRAY05", newSViv( GRAY05 ));
    export_tag("GRAY05", "color");
    newCONSTSUB(FLTK_stash, "GRAY10", newSViv( GRAY10 ));
    export_tag("GRAY10", "color");
    newCONSTSUB(FLTK_stash, "GRAY15", newSViv( GRAY15 ));
    export_tag("GRAY15", "color");
    newCONSTSUB(FLTK_stash, "GRAY20", newSViv( GRAY20 ));
    export_tag("GRAY20", "color");
    newCONSTSUB(FLTK_stash, "GRAY25", newSViv( GRAY25 ));
    export_tag("GRAY25", "color");
    newCONSTSUB(FLTK_stash, "GRAY30", newSViv( GRAY30 ));
    export_tag("GRAY30", "color");
    newCONSTSUB(FLTK_stash, "GRAY33", newSViv( GRAY33 ));
    export_tag("GRAY33", "color");
    newCONSTSUB(FLTK_stash, "GRAY35", newSViv( GRAY35 ));
    export_tag("GRAY35", "color");
    newCONSTSUB(FLTK_stash, "GRAY40", newSViv( GRAY40 ));
    export_tag("GRAY40", "color");
    newCONSTSUB(FLTK_stash, "GRAY45", newSViv( GRAY45 ));
    export_tag("GRAY45", "color");
    newCONSTSUB(FLTK_stash, "GRAY50", newSViv( GRAY50 ));
    export_tag("GRAY50", "color");
    newCONSTSUB(FLTK_stash, "GRAY55", newSViv( GRAY55 ));
    export_tag("GRAY55", "color");
    newCONSTSUB(FLTK_stash, "GRAY60", newSViv( GRAY60 ));
    export_tag("GRAY60", "color");
    newCONSTSUB(FLTK_stash, "GRAY65", newSViv( GRAY65 ));
    export_tag("GRAY65", "color");
    newCONSTSUB(FLTK_stash, "GRAY66", newSViv( GRAY66 ));
    export_tag("GRAY66", "color");
    newCONSTSUB(FLTK_stash, "GRAY70", newSViv( GRAY70 ));
    export_tag("GRAY70", "color");
    newCONSTSUB(FLTK_stash, "GRAY75", newSViv( GRAY75 ));
    export_tag("GRAY75", "color");
    newCONSTSUB(FLTK_stash, "GRAY80", newSViv( GRAY80 ));
    export_tag("GRAY80", "color");
    newCONSTSUB(FLTK_stash, "GRAY85", newSViv( GRAY85 ));
    export_tag("GRAY85", "color");
    newCONSTSUB(FLTK_stash, "GRAY90", newSViv( GRAY90 ));
    export_tag("GRAY90", "color");
    newCONSTSUB(FLTK_stash, "GRAY95", newSViv( GRAY95 ));
    export_tag("GRAY95", "color");
    newCONSTSUB(FLTK_stash, "GRAY99", newSViv( GRAY99 ));
    export_tag("GRAY99", "color");
    newCONSTSUB(FLTK_stash, "BLACK", newSViv( BLACK ));
    export_tag("BLACK", "color");
    newCONSTSUB(FLTK_stash, "RED", newSViv( RED ));
    export_tag("RED", "color");
    newCONSTSUB(FLTK_stash, "GREEN", newSViv( GREEN ));
    export_tag("GREEN", "color");
    newCONSTSUB(FLTK_stash, "YELLOW", newSViv( YELLOW ));
    export_tag("YELLOW", "color");
    newCONSTSUB(FLTK_stash, "BLUE", newSViv( BLUE ));
    export_tag("BLUE", "color");
    newCONSTSUB(FLTK_stash, "MAGENTA", newSViv( MAGENTA ));
    export_tag("MAGENTA", "color");
    newCONSTSUB(FLTK_stash, "CYAN", newSViv( CYAN ));
    export_tag("CYAN", "color");
    newCONSTSUB(FLTK_stash, "WHITE", newSViv( WHITE ));
    export_tag("WHITE", "color");
    newCONSTSUB(FLTK_stash, "DARK_RED", newSViv( DARK_RED ));
    export_tag("DARK_RED", "color");
    newCONSTSUB(FLTK_stash, "DARK_GREEN", newSViv( DARK_GREEN ));
    export_tag("DARK_GREEN", "color");
    newCONSTSUB(FLTK_stash, "DARK_YELLOW", newSViv( DARK_YELLOW ));
    export_tag("DARK_YELLOW", "color");
    newCONSTSUB(FLTK_stash, "DARK_BLUE", newSViv( DARK_BLUE ));
    export_tag("DARK_BLUE", "color");
    newCONSTSUB(FLTK_stash, "DARK_MAGENTA", newSViv( DARK_MAGENTA ));
    export_tag("DARK_MAGENTA", "color");
    newCONSTSUB(FLTK_stash, "DARK_CYAN", newSViv( DARK_CYAN ));
    export_tag("DARK_CYAN", "color");
    newCONSTSUB(FLTK_stash, "WINDOWS_BLUE", newSViv( WINDOWS_BLUE ));
    export_tag("WINDOWS_BLUE", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||Color|color|name

Turn a string into a color. If C<name> is C<undef>, this returns
L<C<NO_COLOR>|/"NO_COLOR">. Otherwise it returns
L<C<FLTK::parsecolor(name, strlen(name))>|FLTK/"parsecolor">.

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
color ( name = 0, g = NO_INIT, b = NO_INIT )
    CASE: items == 3
        int name
        int g
        int b
        C_ARGS: name, g, b
    CASE:
        char * name
        C_ARGS: name

BOOT:
    export_tag("color", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||color|parsecolor|name|n

Turn the first C<n> bytes of C<name> into an FLTK color. This allows you to
parse a color out of the middle of a string.

Recognized values are:

=over

=item * "" turns into NO_COLOR

=item * "0"-"99" decimal fltk color number, only works for indexed color range

=item * "0xnnn" hex value of any fltk color number

=item * "rgb" or "#rgb" three hex digits for rgb

=item * "rrggbb" or "#rrggbb" 2 hex digits for each of rgb

=item * "rrggbbaa" or "#rrggbbaa" fltk color number in hex

=item * "rrrgggbbb" or "#rrrgggbbb" 3 hex digits for each of rgb

=item * "rrrrggggbbbb" or "#rrrrggggbbbb" 4 hex digits for each of rgb

=item * 17 "web safe colors" as defined by CSS 2.1

=item * If FLTK is compiled to use X11, then XParseColor() is tried

=item * all other strings return NO_COLOR.

=back

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
parsecolor ( char * name, unsigned length = strlen(name) )
    OUTPUT:
        RETVAL

BOOT:
    export_tag("parsecolor", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||color|lerp|color1|color2|weight

Return C<(1-weight)*color1 + weight*color2>. C<weight> is clamped to the 0-1
range before use.

=for hackers Found in F<src/setcolor.cxx>

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
lerp ( Color color1, Color color2, float weight )

BOOT:
    export_tag("lerp", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||color|inactive|fore|back

Same as L<C<lerp(fg, bg, .5)>|/"lerp">, it grays out the color.

=for apidoc t[color]||color|inactive|fore|

Same as L<C<lerp(fg, getbgcolor(), .5)>|/"lerp">. This is for
back-compatability only?

=for hackers Found in F<src/setcolor.cxx>

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
inactive ( Color fore, Color back = NO_INIT )

BOOT:
    export_tag("inactive", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||Color|contrast|fg|bg

Returns C<fg> if fltk decides it can be seen well when drawn against a C<bg>.
Otherwise it returns either L<C<FLTK::BLACK>|FLTK/"BLACK"> or
L<C<fltk::WHITE>|FLTK/"WHITE">.

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
contrast ( Color fore, Color back )

BOOT:
    export_tag("contrast", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]|||split_color|color|r|g|b

Set C<r,g,b> to the 8-bit components of this color. If it is an indexed color
they are looked up in the table, otherwise they are simply copied out of the
color number.

=cut

MODULE = FLTK               PACKAGE = FLTK

void
split_color ( Color color, OUTLIST unsigned char r, OUTLIST unsigned char g, OUTLIST unsigned char b )
    C_ARGS: color, r, g, b

BOOT:
    export_tag("split_color", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]|||set_color_index|index|color

Set one of the indexed colors to the given rgb color. \C<index> must be in the
range 0-255, and C<color> must be a non-indexed rgb color.

=cut

MODULE = FLTK               PACKAGE = FLTK

void
set_color_index ( Color index, Color color )

BOOT:
    export_tag("set_color_index", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||get_color_index|color

Return the rgb form of C<color>. If it is an indexed color that entry is
returned. If it is an rgb color it is returned unchanged.

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
get_color_index ( Color color )

BOOT:
    export_tag("get_color_index", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||set_background|color

C<FLTK::GRAY75> is replaced with the passed color, and all the other
C<FLTK::GRAY*> colors are replaced with a color ramp (or sometimes a straight
line) so that using them for highlighted edges of raised buttons looks
correct.

=for hackers Found in F<src/Style.cxx>

=cut

MODULE = FLTK               PACKAGE = FLTK

void
set_background ( Color COLOR )

BOOT:
    export_tag("set_background", "color");

MODULE = FLTK               PACKAGE = FLTK::Color

=for apidoc t[color]||Color|nearest_index|color

Find an indexed color in the range 56-127 that is closest to this color. If
this is an indexed color it is returned unchanged.

=cut

MODULE = FLTK               PACKAGE = FLTK

Color
nearest_index ( Color COLOR )

BOOT:
    export_tag("nearest_index", "color");

#endif // #ifndef DISABLE_COLOR
