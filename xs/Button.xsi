#ifndef DISABLE_BUTTON

MODULE = FLTK               PACKAGE = FLTK::Button

=pod

=for license Artistic License 2.0 | Copyright (C) 2009 by Sanko Robinson

=for author Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

=for abstract Push button widget

=for git $Id$ for got=

=head1 Description

Buttons generate callbacks when they are clicked by the user. You control
exactly when and how by changing the values for L<C<when()>|/"when">:

=over 8

=item C<FLTK::WHEN_NEVER>
The callback is not done, instead L<C<changed()>|/"changed"> is turned on.

=item C<FLTK::WHEN_RELEASE>
This is the default, the callback is done after the user successfully clicks
the button (i.e. they let it go with the mouse still pointing at it), or when
a shortcut is typed.

=item C<FLTK::WHEN_CHANGED>
The callback is done each time the L<C<value()>|/"value"> changes (when the
user pushes and releases the button, and as the mouse is dragged around in and
out of the button).

=back

Buttons can also generate callbacks in response to
L<C<FLTK::SHORTCUT>|FLTK/"SHORTCUT"> events. The button can either have an
explicit L<C<shortcut()>|/"shortcut"> value or a letter shortcut can be
indicated in the L<C<label()>|/"label"> with an C<&> character before it. For
the label shortcut it does not matter if C<Alt> is held down, but if you have
an input field in the same window, the user will have to hold down the C<Alt>
key so that the input field does not eat the event first as an
L<C<FLTK::KEY>|FLTK/"KEY"> event.

=begin apidoc

=cut

#include <fltk/Button.h>

=for apidoc ||FLTK::Button|new|x|y|w|h|label = ""

Creates a new C<FLTK::Button> object. Obviously.

=cut

#include "include/WidgetSubclass.h"

void
fltk::FLTK::Button::new( int x, int y, int w, int h, const char * label = 0 )
    PPCODE:
        void * RETVAL = NULL;
        RETVAL = (void *) new WidgetSubclass<fltk::Button>(CLASS,x,y,w,h,label);
        if (RETVAL != NULL) {
            ST(0) = sv_newmortal();
            sv_setref_pv(ST(0), CLASS, RETVAL); /* -- hand rolled -- */
            XSRETURN(1);
        }

=for apidoc e||int|HIDDEN|

Back-comptability value to hide the button

=cut

int
HIDDEN ( )
    CODE:
        RETVAL = fltk::Button::HIDDEN;
    OUTPUT:
        RETVAL

=for apidoc ||bool|value|value

Change the L<C<value()>|/"value">. Redraws the button and returns true if the
new value is different. This is the same function as
L<C<Widget::state()>|FLTK::Widget/"state">. See also
L<C<Widget::set()>|FLTK::Widget/"set">,
L<C<Widget::clear()>|FLTK::Widget/"clear">, and
L<C<Widget::setonly()>|FLTK::Widget/"setonly">.

If you turn it on, a normal button will draw pushed-in, until the user clicks
it and releases it.

=for apidoc ||bool|value|

The current value. C<true> means it is pushed down, C<false> means it is not
pushed down. The L<ToggleButton|FLTK::ToggleButton> subclass provides the
ability for the user to change this value permanently, otherwise it is just
temporary while the user is holding the button down.

This is the same as L<Widget::state()|FLTK::Widget/"state">.

=cut

bool
fltk::Button::value ( bool value = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->value( );
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            THIS->value( value );

#ifndef DISABLE_HANDLE

=for apidoc ||int|handle|event|rectangle



=for apidoc ||int|handle|event



=cut

int
fltk::Button::handle ( int event, fltk::Rectangle * rectangle = NO_INIT )
    CASE: items == 2
        C_ARGS: event
    CASE:
        C_ARGS: event, * rectangle

#endif // #ifndef DISABLE_HANDLE

=for apidoc ||FLTK::NamedStyle|default_style|

NFI

=cut

fltk::NamedStyle *
fltk::Button::default_style ( )
    CODE:
        RETVAL = THIS->default_style;
    OUTPUT:
        RETVAL

=for apidoc |||draw|glyph_width

This function provides a mess of back-compatabilty and Windows emulation to
subclasses of Button to draw with. It will draw the button according to the
current state of being pushed and it's L<C<state()>|/"state">. If non-zero is
passed for C<GLYPH_WIDTH> then the L<C<glyph()>|/"glyph"> is drawn in that
space on the left (or on the right if negative), and it assummes the glyph
indicates the L<C<state()>|/"state">, so the box is only used to indicate the
pushed state.

=cut

BOOT:
    isa("FLTK::Button", "FLTK::Widget");

#endif // ifndef DISABLE_BUTTON
