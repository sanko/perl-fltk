#ifndef DISABLE_ASK

MODULE = FLTK               PACKAGE = FLTK::ask

=pod

=for license Artistic License 2.0 | Copyright (C) 2009 by Sanko Robinson

=for author Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

=for version 0.530

=for git $Id$

=head1 NAME

FLTK::ask - Implementation of message, ask, choice, and input functions

=head1 Description

Implementation of L<C<FLTK::message()>|/"message">,
L<C<FLTK::ask(...)>|/"ask">, L<C<FLTK::choice(...)>|/"choice">,
L<C<FLTK::input()>|/"input">.

=begin apidoc

=cut

#include <fltk/ask.h>

=for apidoc T[dialog]E||int beep|BEEP_DEFAULT|



=for apidoc T[dialog]E||int beep|BEEP_MESSAGE|



=for apidoc T[dialog]E||int beep|BEEP_ERROR|



=for apidoc T[dialog]E||int beep|BEEP_QUESTION|



=for apidoc T[dialog]E||int beep|BEEP_PASSWORD|



=for apidoc T[dialog]E||int beep|BEEP_NOTIFICATION|



=cut

BOOT:
    newCONSTSUB(FLTK_stash, "BEEP_DEFAULT", newSViv( BEEP_DEFAULT ));
    export_tag("BEEP_DEFAULT", "dialog");
    newCONSTSUB(FLTK_stash, "BEEP_MESSAGE", newSViv( BEEP_MESSAGE ));
    export_tag("BEEP_MESSAGE", "dialog");
    newCONSTSUB(FLTK_stash, "BEEP_ERROR", newSViv( BEEP_ERROR ));
    export_tag("BEEP_ERROR", "dialog");
    newCONSTSUB(FLTK_stash, "BEEP_QUESTION", newSViv( BEEP_QUESTION ));
    export_tag("BEEP_QUESTION", "dialog");
    newCONSTSUB(FLTK_stash, "BEEP_PASSWORD", newSViv( BEEP_PASSWORD ));
    export_tag("BEEP_PASSWORD", "dialog");
    newCONSTSUB(FLTK_stash, "BEEP_NOTIFICATION", newSViv( BEEP_NOTIFICATION ));
    export_tag("BEEP_NOTIFICATION", "dialog");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog,default]F|||message|char * string|

Displays a message in a pop-up box with an "OK" button, waits for the user to
hit the button. The message will wrap to fit the window, or may be many lines
by putting C<\n> characters into it. The enter key is a shortcut for the OK
button.

=for apidoc T[dialog,default]F|||alert|char * string|

Same as L<C<FLTK::message()>|/"message"> except for the "!" symbol.

=cut

MODULE = FLTK               PACKAGE = FLTK

void
message( char * string )

BOOT:
    export_tag("message", "dialog");
    export_tag("message", "default");

void
alert( char * string )

BOOT:
    export_tag("alert", "dialog");
    export_tag("alert", "default");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog]F||int choice|ask|char * question|

Displays a message in a pop-up box with a "Yes" and "No" button and waits for
the user to hit a button. The return value is C<1> if the user hits "Yes",
C<0> if they pick "No". The C<Enter> key is a shortcut for "Yes" and C<ESC> is
a shortcut for "No".

If L<C<message_window_timeout>|/"message_window_timeout"> is used, then C<-1>
will be returned if the timeout expires.

=cut

MODULE = FLTK               PACKAGE = FLTK

int
ask( char * question )

BOOT:
    export_tag("ask", "dialog");
    export_tag("ask", "default");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog,default]F||int choice|choice|char * question|char * answer_1|char * answer_2|char * answer_3|

Shows the message with three buttons below it marked with the strings
C<answer_1>, C<answer_2>, and C<answer_3>. Returns C<0>, C<1>, or C<2>
depending on which button is hit. If one of the strings begins with the
special character '*' then the associated button will be the default which is
selected when the C<Enter> key is pressed. C<ESC> is a shortcut for
C<answer_1>.

If L<C<message_window_timeout>|/"message_window_timeout"> is used, then C<-1>
will be returned if the timeout expires.

=for apidoc T[dialog,default]F||int choice|choice_alert|char * question|char * question|char * answer_1|char * answer_2|char * answer_3|

Same as L<C<choice()>|/"choice"> except a "!" icon is used instead of a "?"

=cut

MODULE = FLTK               PACKAGE = FLTK

int
choice( char * question, char * answer_1, char * answer_2, char * answer_3)
    CODE:
        int a;
        switch ( ix ) {
            case 0: a = fltk::choice(question, answer_3, answer_2, answer_1); break;
            case 1: a = fltk::choice_alert(question, answer_3, answer_2, answer_1); break;
        }
        RETVAL = a == 0 ? 2 : a == 2 ? 0 : a;
    OUTPUT:
        RETVAL
    ALIAS:
        choice_alert = 1

BOOT:
    export_tag("choice", "dialog");
    export_tag("choice", "default");
    export_tag("choice_alert", "dialog");
    export_tag("choice_alert", "default");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog,default]F||char * string|input|char * label|char * default_value = ''|

Pops up a window displaying a string, lets the user edit it, and return the
new value. The cancel button returns C<undef>. The returned pointer is only
valid until the next time L<C<FLTK::input()>|FLTK::ask/"input"> is called.

If L<C<message_window_timeout>|/"message_window_timeout"> is used, then C<0>
will be returned if the timeout expires.

=for apidoc T[dialog,default]Fx||char * string|password|char * label|char * default_value = ''|

Same as L<C<FLTK::input()>|FLTK::ask/"input"> except an
L<FLTK::SecretInput|FLTK::SecretInput> field is used.

=cut

MODULE = FLTK               PACKAGE = FLTK

const char *
input( char * label, char * default_value = 0 )
    CODE:
        switch( ix ) {
            case 0: RETVAL = fltk::input( label, default_value ); break;
            case 1: RETVAL = fltk::password( label, default_value ); break;
        }
    OUTPUT:
        RETVAL
    ALIAS:
        password = 1

BOOT:
    export_tag("input", "dialog");
    export_tag("input", "default");
    export_tag("password", "dialog");
    export_tag("password", "default");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog,default]F|||beep|int type = FLTK::ask::BEEP_DEFAULT|

Generates a simple beep message.

=cut

MODULE = FLTK               PACKAGE = FLTK

void
beep( int type = fltk::BEEP_DEFAULT )

BOOT:
    export_tag("beep", "dialog");
    export_tag("beep", "default");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog]F|||beep_on_dialog|bool value

You can enable beep on default message dialog (like L<C<ask>|/"dialog">,
L<C<choice>|/"choice">, L<C<input>|/"input">, ...) by using this function with
true (default is false).

=for apidoc T[dialog]F||bool value|beep_on_dialog||

You get the state enable beep on default message dialog (like
L<C<ask>|/"dialog">, L<C<choice>|/"choice">, L<C<input>|/"input">, ...) by using
this function with true (default is false).

=cut

MODULE = FLTK               PACKAGE = FLTK

bool
beep_on_dialog( bool value = NO_INIT )
    CASE: items == 1
        CODE:
            fltk::beep_on_dialog( value );
    CASE:
        C_ARGS:

BOOT:
    export_tag("beep_on_dialog", "dialog");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog]F||FLTK::NamedStyle style|icon_style||

This L<Style|FLTK::Style> is used for the C<50x50> icon area on the left of
all the popup windows. You can change the colors or font used here.

=for apidoc T[dialog]F|||icon_style|FLTK::NamedStyle style|

Set the icon style.

=for apidoc T[dialog]F||FLTK::NamedStyle style|message_style||

This L<Style|FLTK::Style> is used for the label area for all the popup
windows. You can change the L<C<textfont()>|FLTK::Style/"textfont"> or
L<C<textsize()>|FLTK::Style/"textsize"> to make them print differently.

=for apidoc T[dialog]F|||message_style|FLTK::NamedStyle style|

Set the message style.

=cut

MODULE = FLTK               PACKAGE = FLTK

fltk::NamedStyle *
icon_style( fltk::NamedStyle * style = NO_INIT )
    CASE: items == 1
        CODE:
            switch ( ix ) {
                case 0: fltk::icon_style = style; break;
                case 1: fltk::message_style = style; break;
            }
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            switch ( ix ) {
                case 0: RETVAL = fltk::icon_style; break;
                case 1: RETVAL = fltk::message_style; break;
            }
        OUTPUT:
            RETVAL
    ALIAS:
        message_style = 1

BOOT:
    export_tag("icon_style", "dialog");
    export_tag("message_style", "dialog");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog]F||char * label|message_window_label||

Get the title of L<C<message()>|/"message">, L<C<alert()>|/"alert">,
L<C<ask()>|/"dialog">, L<C<choice()>|/"choice">, etc. windows.

=for apidoc T[dialog]F|||message_window_label|char * label|

Set this to change the title of L<C<message()>|/"message">,
L<C<alert()>|/"alert">, L<C<ask()>|/"dialog">, L<C<choice()>|/"choice">, etc.
windows.

=for apidoc F||char * label|no||

Returns the current value for this variable.

=for apidoc F|||no|char * label|

You can change this string to convert fltk to a foreign language.

=for apidoc F||char * label|yes||

Returns the current value for this variable.

=for apidoc F|||yes|char * label|

You can change this string to convert fltk to a foreign language.

=for apidoc F||char * label|ok||

Returns the current value for this variable.

=for apidoc F|||ok|char * label|

You can change this string to convert fltk to a foreign language.

=for apidoc F||char * label|cancel||

Returns the current value for this variable.

=for apidoc F|||cancel|char * label|

You can change this string to convert fltk to a foreign language.

=cut

MODULE = FLTK               PACKAGE = FLTK

const char *
message_window_label ( char * label = NO_INIT )
    CASE: items == 1
        CODE:
            switch( ix ) {
                case 0: fltk::message_window_label = label; break;
                case 1:                   fltk::no = label; break;
                case 2:                  fltk::yes = label; break;
                case 3:                   fltk::ok = label; break;
                case 4:               fltk::cancel = label; break;
            }
    CASE:
        CODE:
            switch ( ix ) {
                case 0: RETVAL = fltk::message_window_label; break;
                case 1: RETVAL = fltk::no;     break;
                case 2: RETVAL = fltk::yes;    break;
                case 3: RETVAL = fltk::ok;     break;
                case 4: RETVAL = fltk::cancel; break;
            }
        OUTPUT:
            RETVAL
    ALIAS:
            no = 1
           yes = 2
            ok = 3
        cancel = 4

BOOT:
    export_tag("message_window_label", "dialog");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog]F||double timeout|message_window_timeout||

Returns the current value for
L<C<message_window_timeout(...)>|/"message_window_timeout">.

=for apidoc T[dialog]F|||message_window_timeout|double timeout|

Set this to a positive value to cause the L<C<message()>|/"message">,
L<C<alert()>|/"alert">, L<C<ask()>|/"dialog">, L<C<choice()>|/"choice">, etc.
windows to close automatically after this timeout. If the timeout expires,
C<-1> will be returned by the functions that return integers. The timeout
value is a float in seconds.

=cut

MODULE = FLTK               PACKAGE = FLTK

double
message_window_timeout( double timeout = NO_INIT )
    CASE: items == 1
        CODE:
            fltk::message_window_timeout = timeout;
    CASE:
        CODE:
            RETVAL = fltk::message_window_timeout;
        OUTPUT:
            RETVAL

BOOT:
    export_tag("message_window_timeout", "dialog");

MODULE = FLTK               PACKAGE = FLTK::ask

=for apidoc T[dialog]F||bool scroll|message_window_scrollable||

Returns current value of
L<C<message_window_scrollable(...)>|/"message_window_scrollable">.

=for apidoc T[dialog]F|||message_window_scrollable|bool scroll|

When this is set to true, then (all) message windows will use scrollbars if
the given message is too long.

=cut

MODULE = FLTK               PACKAGE = FLTK

bool
message_window_scrollable( bool scroll = NO_INIT )
    CASE: items == 1
        CODE:
            fltk::message_window_scrollable = scroll;
    CASE:
        CODE:
            RETVAL = fltk::message_window_scrollable;
        OUTPUT:
            RETVAL

BOOT:
    export_tag("message_window_scrollable", "dialog");

#endif // ifndef DISABLE_ASK
