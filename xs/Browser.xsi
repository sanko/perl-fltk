MODULE = FLTK               PACKAGE = FLTK::Browser

#if 1

=pod

=head1 Description

Displays a scrolling vertical list of text widgets, possibly with a
hierarchical arrangement, and lets the user select one of them.

The items may be created as child widgets (usually the same widgets as are
used to create menus: L<FLTK::Item|FLTK::Item> widgets, or
L<FLTK::ItemGroup|FLTK::ItemGroup> widgets to make a hierarchy).

All the functions used to add, remove, or modify items in the list are defined
by the base class L<FLTK::Menu|FLTK::Menu>. See that for much more
information. For a simple constant list you can populate the list by calling
C<browser->add("text of item")> once for each item.

See also:

=over 8

=item C<add()>

=item C<add_group()>

=item C<add_leaf()>

=back

You can also use an L<FLTK::List|FLTK::List> which allows you to control the
storage by dynamically creating a temporary "fake" widget for the browser to
use each time it wants to look at or draw an item. This is useful for creating
browsers with hundreds of thousands of items, or when the set of items changes
rapidly.

If you give the browser a callback you can find out what item was selected
with L<C<value()>|/"value">, the first item is zero (this is different from
older versions of fltk that started at C<1>!), and will be negative if no item
is selected. You can change the selected item with
L<C<value(new_value)>|/"value">.

The subclass L<FLTK::MultiBrowser|FLTK::MultiBrowser> lets the user select
more than one item at the same time.

The L<C<callback()>|/"callback"> is done when the user changes the selected
items or when they open/close parents. In addition, if the user double-clicks
a non-parent item, then it is "executed" which usually means that the
L<C<callback()>|/"callback"> on the item itself is run. However, if no
callback has been set on the item, the L<C<callback()>|/"callback"> of this
widget is called with the L<C<user_data()>|/"user_data"> of the item.

You can control when callbacks are done with the L<C<when()>|/"when"> method.
The following values are useful, the default value is C<FLTK::WHEN_CHANGED>.

=over 8

=item C<FLTK::WHEN_NEVER

Callback is never done. L<C<changed()>|/"changed"> can be used to see if the
user has modified the browser.

=item C<FLTK::WHEN_CHANGED>

Callback is called on every change to each item as it happens. The method
L<C<item()>|/"item">) will return the one that is being changed. Notice that
selecting large numbers in a mulit browser will produce large numbers of
callbacks.

=item C<FLTK::WHEN_RELEASE>

Callback is done when the user releases the mouse after some changes, and on
any keystroke that changes the item. For a multi browser you will only be able
to find out all the changes by scanning all the items in the callback.

=item C<FLTK::WHEN_RELEASE_ALWAYS>

Callback is done when the user releases the mouse even if the current item has
not changed, and on any arrow keystroke even when at the top or bottom of the
browser.

=item C<FLTK::WHEN_ENTER_KEY>

If you turn this on then the enter key is a shortcut and executes the current
item like double-click.

=back

Inherits L<FLTK::Menu|FLTK::Menu>.

Inherited by L<FLTK::ComboBrowser|FLTK::ComboBrowser>,
L<FLTK::FileBrowser|FLTK::FileBrowser>, and
L<FLTK::MultiBrowser|FLTK::MultiBrowser>.

=cut

#include <fltk/Browser.h>

=for apidoc e||int|IS_MULTI|

Means multiple selection can be achieved by user.

=cut

int
IS_MULTI ( )
    CODE:
        RETVAL = fltk::Browser::IS_MULTI;
    OUTPUT:
        RETVAL

=for apidoc e||int|NORMAL|

Means a single selection can be achieved by user.

=cut

int
NORMAL ( )
    CODE:
        RETVAL = fltk::Browser::NORMAL;
    OUTPUT:
        RETVAL

=for apidoc e||int|MULTI|

Means multiple selection can be achieved by user.

=cut

int
MULTI ( )
    CODE:
        RETVAL = fltk::Browser::MULTI;
    OUTPUT:
        RETVAL

=for apidoc e||int|NO_COLUMN_SELECTED|

Means that no column has been selected by user.

=cut

int
NO_COLUMN_SELECTED ( )
    CODE:
        RETVAL = fltk::Browser::NO_COLUMN_SELECTED;
    OUTPUT:
        RETVAL

=for apidoc e||linepos|NOSCROLL|

Argument to L<C<make_item_visible()>|/"make_item_visible">.

Moves as little as possible so item is visible.

=cut

fltk::Browser::linepos
NOSCROLL ( )
    CODE:
        RETVAL = fltk::Browser::NOSCROLL;
    OUTPUT:
        RETVAL

=for apidoc e||linepos|TOP|

Position current item to top

=cut

fltk::Browser::linepos
TOP ( )
    CODE:
        RETVAL = fltk::Browser::TOP;
    OUTPUT:
        RETVAL

=for apidoc e||linepos|MIDDLE|

Position current item to middle

=cut

fltk::Browser::linepos
MIDDLE ( )
    CODE:
        RETVAL = fltk::Browser::MIDDLE;
    OUTPUT:
        RETVAL

=for apidoc e||linepos|BOTTOM|

Position current item to bottom

=cut

fltk::Browser::linepos
BOTTOM ( )
    CODE:
        RETVAL = fltk::Browser::BOTTOM;
    OUTPUT:
        RETVAL

=for apidoc d|||new|X|Y|Width|Height|Label = ''

Creates a new C<FLTK::Browser> object.

=cut

fltk::Browser *
fltk::Browser::new ( X, Y, Width, Height, Label = "" )
    int     X
    int     Y
    int     Width
    int     Height
    char *  Label
    CODE:
        RETVAL = new fltk::Browser( X, Y, Width, Height, Label );
        RETVAL->copy_label( Label );
    OUTPUT:
        RETVAL

#if ALLOW_DESTROY

=for apidoc h|||DESTROY|

The destructor deletes all the list items (because they are child
L<widgets/FLTK::Widgets> of a L<group|FLTK::Group>).

=cut

bool
fltk::Browser::DESTROY ( )
    CODE:
#if VERBOSE >= 2
        warn ( "Bye, Browser (label: '%s')", THIS->label());
#endif
        delete THIS;
        RETVAL = true;
    OUTPUT:
        RETVAL

#endif

#if 0

=for apidoc H||bool|at_mark|Mark

TODO

=cut

bool
fltk::Browser::at_mark ( MARK )
    const Mark & MARK

#endif

=for apidoc |||bottomline|int

Convenience function for non-hierarchial browsers. Make the indexed item
visible and scroll to put it at the bottom of the browser.

=cut

void
fltk::Browser::bottomline ( LINE )
    int LINE

=for apidoc ||int|box_height|

The height of the display area of the browser in pixels, this is
L<C<h()>|/"h"> minus the edges of the L<C<box()>|/"box"> minus the height of
the horizontal scrollbar, if visible. If this is changed (by resizing the
widget, adding or deleting items or opening or closing a parent item such that
the scrollbar visibility changes) then L<C<layout()>|/"layout"> must be called
before this is correct.

=cut

int
fltk::Browser::box_height ( )

=for apidoc ||int|box_width|

The width of the display area of the browser in pixels, this is
L<C<w()>|/"w"> minus the edges of the L<C<box()>|/"box"> minus the width of
the vertical scrollbar, if visible. If this is changed (by resizing the
widget, adding or deleting items or opening or closing a parent item such that
the scrollbar visibility changes) then L<C<layout()>|/"layout"> must be called
before this is correct.

=cut

int
fltk::Browser::box_width ( )

#if 0

=for apidoc |||column_labels|LABELS

Set an array of labels to put at the top of the browser. The initial sizes of
them are set with L<C<column_widths()>|/"column_widths">. Items in the browser
can print into the correct columns by putting C<\t'> characters into their
text. Or they can look at L<C<FLTK::column_widths()>|FLTK/"column_widths"> to
find the settings from their L<C<draw()>|/"draw"> methods.

=cut

=for apidoc ||STRING|column_labels|

Get the array of labels at the top of the browser.

=cut

const char **
fltk::Browser::column_labels ( LABELS = NO_INIT )
    CASE: items
        const char ** LABELS
        OUTPUT:
            LABELS
    CASE:
        CODE:
            RETVAL = THIS->column_labels( );
        OUTPUT:
            RETVAL

#endif

=for |||column_widths|WIDTHS

Sets the horizontal locations that each C<\t> character in an item should
start printing text at. These are measured from the left edge of the browser,
including any area for the open/close + glyphs.

=over 8

=item Array must end with 0 (zero) always

=item You can define flexible column by setting column width to -1. If you
have flexible column in browser, all columns are resized to match width of the
browser, by resizing flexible column.

  # Example 1: make three columns, total width of columns is 300 pixels.
  # Columns are resizable, but total width is kept always.
  my @widths = [ 100, 100, 100, 0 ];

  # Example 2: make three columns, total width of columns is always width of
  # the browser. Columns are resizable, third column is flexible and will take
  # remaining space left.
  my @widths = [ 100, 100, -1, 0 ];

=cut

=for ||int|column_widths|

Gets the horizontal locations that each C<\t> character in an item should
start printing text at.

=cut

int
fltk::Browser::column_widths ( WIDTHS = NO_INIT )
    CASE: items
        int WIDTHS
        CODE:
            THIS->column_widths( (const int *) WIDTHS );
    CASE:
        CODE:
            RETVAL = (int) THIS->column_widths( );
        OUTPUT:
            RETVAL

#if 0

=for apidoc ||int|compare_to_mark|Mark

NFI

=cut

int
fltk::Browser::compare_to_mark ( MARK )
    Mark & MARK

#endif

=for apidoc ||int|current_index||

Return an array of C<L<current_level()|/"current_level">+1> indexes saying
which child at each level includes the current item.

=cut

const int *
fltk::Browser::current_index ( )

=for apidoc ||int|current_level|

Return the nesting level of the current item (how many parents it has).

=cut

int
fltk::Browser::current_level ( )

=for apidoc ||int|current_position|

Return the C<y> position, in pixels, of the top edge of the current item. You
may also want the height, which is in L<C<item_h()>|/"item_h">.

=cut

int
fltk::Browser::current_position ( )

=for apidoc |||damage_item|Mark

Set item referenced by this mark as being damaged.

=cut

#if 0

=for apidoc |||damage_item|

Tell the browser to redraw the current item. Do this if you know it has
changed appearance. This is better than redrawing the entire browser because
it will blink a lot less.

=cut

void
fltk::Browser::damage_item ( MARK = NO_INIT )
    CASE: items == 2

        const Mark & MARK
        CODE:
            THIS->damage_item( MARK );

    CASE:
        CODE:
            THIS->damage_item( );

#endif

=for apidoc ||bool|deselect|DO_CALLBACK = 0

Turn off selection of all items in the browser. For the normal (not
L<Multi|FLTK::MultiBrowser>) L<Browser|FLTK::Browser>, this puts it in a
special state where nothing is highlighted andL<C<index(0)>|/"index"> returns
C<-1>. The user cannot get it into this state with the GUI.

For a L<MultiBrowser|FLTK::MultiBrowser> the user can get this state by
C<ctrl>+clicking the selected items off.

If C<DO_CALLBACK> has some bits that are also in L<C<when()>|/"when"> then the
callback is done for each item that changes selected state.

=cut

bool
fltk::Browser::deselect ( DO_CALLBACK = 0 )
    int DO_CALLBACK

=for apidoc ||bool|display|LINE|VALUE = true

Convenience function for non-hierarchial browsers. Make the indexed item be
L<C<visible()>|/"visible"> and scroll the browser so it can be seen by the
user.

=cut

bool
fltk::Browser::display ( LINE, VALUE = true )
    int LINE
    bool VALUE

=for apidoc |||display_lines|DISPLAY

Accessor (set) method which is used to set the value of the C<displaylines_>
member. If you set C<DISPLAY> to C<false> it will mean that you do not want
lines of the tree to be displayed.

=cut

=for apidoc ||bool|display_lines|

Accessor (get) method which returns C<true> if lines should be displayed, or
C<false> otwherwize.

=cut

bool
fltk::Browser::display_lines ( DISPLAY = true )
    CASE: items
        bool DISPLAY
        CODE:
            THIS->display_lines( DISPLAY );
    CASE:
        CODE:
            RETVAL = THIS->display_lines( );

=for apidoc ||bool|displayed|LINE

Convenience function for non-hierarchial browsers. Returns C<true> if the
indexed item is visible (ie not hidden).

=cut

bool
fltk::Browser::displayed ( LINE )
    int LINE

=for apidoc |||draw|

NFI

=cut

void
fltk::Browser::draw ( )

=for apidoc ||int|focus_index|

Return an array of C<L<focus_level()|/"focus_level">+1> indexes saying which
child at each level includes the focus.

Reimplemented from L<FLTK::Group|FLTK::Group>.

=cut

const int *
fltk::Browser::focus_index ( )

=for apidoc ||int|focus_level|

Return the nesting level of the focus (how many parents it has). The focus is
the selected item the user sees.

=cut

int
fltk::Browser::focus_level ( )

=for apidoc ||int|focus_position|

Return the C<y> position, in pixels, of the top edge of the current item. You
may also want the height, which is in L<C<item_h()>|/"item_h">.

=cut

int
fltk::Browser::focus_position ( )

=for apidoc ||FLTK::Widget|goto_focus|

Sets the L<C<item()>|/"item"> to the "focus" (the item with the dotted square
in an L<FLTK::MultiBrowser|FLTK::MultiBrowser>, and the selected item in a
normal L<FLTK::Browser|FLTK::Browser>.

=cut

fltk::Widget *
fltk::Browser::goto_focus ( )

=for apidoc ||FLTK::Widget|goto_index|A|B|C = -1|D = -1|E = -1

Go to an item at any level up to C<5>. Negative numbers indicate that no more
levels should be looked at.

=cut

=for apidoc ||FLTK::Widget|goto_index|@INDEXES|LEVAL

Go to a nested item. indexes must contain C<LEVEL+1> index numbers. The first
number indicates the top-level item number, the second indicates the child
number of that parent, and so on. This sets the current L<C<item()>|/"item">
to the given item and also returns it. If the values are out of range then
C<undef> is returned.

A negative number in C<$INDEXES[0]> will make it go into a special no-item
state where L<C<select_only_this()>|/"select_only_this"> will do
L<C<deselect()>|/"deselect">.

=cut

=for apidoc ||FLTK::Widget|goto_index|INDEX

Go to the C<INDEX>'th item in the top level. If C<INDEX> is out of range,
C<undef> is returned.

=cut

fltk::Widget *
fltk::Browser::goto_index (A, B = NO_INIT, C = -1, D = -1, E = -1)
    CASE: items == 1
        int A
        C_ARGS: A
    CASE: items == 2
        int      A
        unsigned B
        C_ARGS: (const int *) A, B
    CASE:
        int A
        int B
        int C
        int D
        int E
        C_ARGS: A, B, C, D, E

#if 0

=for apidoc ||FLTK::Widget|goto_mark|Mark

Set current item to a particular mark.

=cut

fltk::Widget *
fltk::Browser::goto_mark ( MARK )
    const Mark & MARK

#endif

=for apidoc ||FLTK::Widget|goto_position|Y

Set the current L<C<item()>|/"item"> to the last one who's top is at or before
C<Y> pixels from the top.

=cut

fltk::Widget *
fltk::Browser::goto_position ( Y )
    int Y

=for apidoc ||FLTK::Widget|goto_top|

Because of the hierarchial structure it is difficult to identify an item in
the browser. Instead of passing an identifier to all the calls that can modify
an item, the browser provides several calls to set L<C<item()>|/"item"> based
on various rules, and then calls to modify the current L<C<item()>|/"item">.

This call sets L<C<item()>|/"item"> to the very first visible widget in the
browser. It returns the widget for that item, or null if the browser is empty.

If you have invisible items in the browser you should use
L<C<goto_index(0)>|/"goto_index"> if you want to go to the first item even if
it is invisible.

=cut

fltk::Widget *
fltk::Browser::goto_top ( )

=for apidoc |||group_symbol|Symbol

Sets a default value for L<C<image()>|/"image"> on each item that is a
hierarchy parent. If the parent item has no L<C<image()>|/"image"> then this
one is used for it.

=cut

=for apidoc ||Symbol|group_symbol|

Gets a default value for L<C<image()>|/"image"> on each item that is a
hierarchy parent.

=cut

const fltk::Symbol *
fltk::Browser::group_symbol ( SYMBOL = NO_INIT )
    CASE: items
        const fltk::Symbol * SYMBOL
        CODE:
            THIS->group_symbol( SYMBOL );
    CASE:
        CODE:
            RETVAL = THIS->group_symbol( );
        OUTPUT:
            RETVAL

=for apidoc h||int|handle|HANDLE

NFI

=cut

int
fltk::Browser::handle ( HANDLE )
    int HANDLE

=for apidoc ||FLTK::Widget|header|COL

Return pointer to L<Widget|FLTK::Widget> in column C<COL>, starting from index
C<0>. If column C<COL> is invalid, C<undef> is returned.

=cut

fltk::Widget *
fltk::Browser::header ( COL )
    int COL

=for apidoc ||int|height|

The height of all the visible items in the browser, measured in pixels. If
this is changed (by adding or deleting items or opening or closing a parent
item) then L<C<layout()>|/"layout"> must be called before this is correct.

=cut

int
fltk::Browser::height ( )

=for apidoc |||indented|INDENT = false

Turn this on to for space to be reserved for open/close boxes drawn to the
left of top-level items. You usually want this for a hierarchial browser. This
should be off for a flat browser, or to emulate Windows Explorer where
"My Computer" does not have an open/close to the left of it. The default value
is C<false>.

=cut

=for apidoc ||bool|indented|

Getter...

=cut

bool
fltk::Browser::indented ( INDENTED = false )
    CASE: items
        bool INDENTED
        CODE:
            THIS->indented( INDENTED );
    CASE:
        CODE:
            RETVAL = THIS->indented( );
        OUTPUT:
            RETVAL

=for apidoc ||int|item_h|

NFI

=cut

int
fltk::Browser::item_h ( )

=for apidoc ||bool|item_is_open|

If L<C<item_is_parent()>|/"item_is_parent"> is C<true>, return C<true> if this
item is open. If this is not a parent the result is undefined.

=cut

bool
fltk::Browser::item_is_open ( )

=for apidoc ||bool|item_is_parent|

Return C<true> if the current item is a parent. Notice that it may have zero
children.

=cut

bool
fltk::Browser::item_is_parent ( )

=for apidoc ||bool|item_is_visible|

Return C<true> if the item would be visible to the user if the browser was
scrolled to the correct location. This means that the C<FLTK::INVISIBLE> flag
is not set on it, and all parents of it are open and visible as well.

=cut

bool
fltk::Browser::item_is_visible ( )

=for apidoc |||layout|

NFI

=cut

void
fltk::Browser::layout ( )


=for apidoc |||leaf_symbol|fltk::Symbol

Sets a default value for L<C<image()>|/"image"> on each item that is not a
parent of other items. If the item has no L<C<image()>|/"image"> then this one
is used for it.

=cut

=for apidoc ||fltk::Symbol|leaf_symbol|

Gets a default value for L<C<image()>|/"image"> on each item that is not a
parent of other items. If the item has no L<C<image()>|/"image"> then this one
is used for it.

=cut

const fltk::Symbol *
fltk::Browser::leaf_symbol ( SYMBOL = NO_INIT )
    CASE: items
        const fltk::Symbol * SYMBOL
        CODE:
            THIS->leaf_symbol( SYMBOL );
    CASE:
        CODE:
            RETVAL = THIS->leaf_symbol( );
        OUTPUT:
            RETVAL

=for apidoc ||int|load|FILENAME

NFI

=cut

int
fltk::Browser::load ( FILENAME )
    const char * FILENAME

=for apidoc ||bool|make_item_visible|WHERE = NOSCROLL

This makes the current item visible to the user.

First it turns off the C<FLTK::INVISIBLE> flag on the current item, and turns
off the C<FLTK::INVISIBLE> flag and opens (turning on the C<FLTK::STATE> flag)
all parent items. These flag changes cause
L<C<flags_changed()>|/"flags_changed">) to be called on any
L<FLTK::List|FLTK::List> that you have assigned to the browser.

The browser is then scrolled by calling L<C<yposition()>|/"yposition"> so the
item is visible. The optional argument tells how to scroll. If not specified
(or the default value of
L<C<FLTK::Browser::NOSCROLL>|FLTK::Browser/"NOSCROLL"> is given) then the
browser is scrolled as little as possible to show the item. If it is
L<C<FLTK::Browser::TOP>|FLTK::Browser/"TOP"> then the item is put at the top
of the browser. If it is L<C<FLTK::Browser::MIDDLE>|FLTK::Browser/"MIDDLE">
then the item is centered vertically in the browser. If it is
L<C<FLTK::Browser::BOTTOM>|FLTK::Browser/"BOTTOM"> then the item is put at the
bottom of the browser.

This does nothing if the current item is null.

=cut

bool
fltk::Browser::make_item_visible ( WHERE = (fltk::Browser::linepos) NULL )
    fltk::Browser::linepos WHERE

=for apidoc |||middleline|LINE

Convenience function for non-hierarchial browsers. Make the indexed item
visible and scroll to put it in the middle of the browser if it is not already
visible (passes C<undef> to L<C<make_item_visible()>|/"make_item_visible">.

=cut

void
fltk::Browser::middleline ( LINE )
    int LINE

=for apidoc ||int|multi

NFI

=cut

int
fltk::Browser::multi ( )

=for apidoc ||FLTK::Widget|next|

Move the current item to the next item. If it is a parent it moves to the
first child. If not a parent, it moves to the next child of it's parent. If it
is the last child it moves to the parent's brother. Repeatedly calling this
will visit every child of the browser. This returns the widget. If the current
widget is the last one this returns null, but the current widget remains on
the last one.

The L<C<current_position()>|/"current_position"> is B<NOT> set by this! It
cannot be calculated efficiently and would slow down the use of this function
for visiting all items.

=cut

fltk::Widget *
fltk::Browser::next ( )

=for apidoc ||FLTK::Widget|next_visible|

Move forward to the next visible item (what down-arrow does). This does not
move and returns null if we are at the bottom.

=cut

fltk::Widget *
fltk::Browser::next_visible ( )

=for apidoc ||int|nheader|

Returns number of columns in browser.

=cut

int
fltk::Browser::nheader ( )

=for apidoc ||FLTK::Widget|previous_visible|

Move backward to previous visible item: This does not move and returns
C<undef> if we are at the top.

=cut

fltk::Widget *
fltk::Browser::previous_visible ( )

#if 0

=for apidoc |||bool|select|LINE|VALUE = true

Same as C<L<goto_index(line)|/"goto_index">, set_item_selected(value)|/"set_item_selected">>,
to change the selected state of an item in a non-hierarchial
L<MultiBrowser|FLTK::MultiBrowser>. If line is out of range nothing happens.

=cut

=for apidoc |||bool|select|WIDGET|VALUE|DO_CALLBACK = 0

This is for use by the L<MultiBrowser|FLTK::MultiBrowser> subclass. select or
deselect an item in parameter, optionally execute a callback (calls
L<C<set_item_selected()>|/"set_item_selected">). This method changes item
position in the tree.

=cut

bool
fltk::Browser::select ( LINE, VALUE = true, DO_CALLBACK = 0 )
    CASE: (SvIOK(ST(1))) && (items <= 2)
        int  LINE
        bool VALUE
        C_ARGS: LINE, VALUE
    CASE: 1 /* TODO: make sure ST(1) is an object */
        fltk::Widget * LINE
        int            VALUE
        int            DO_CALLBACK
        C_ARGS: LINE, VALUE, DO_CALLBACK

#endif

=for apidoc ||bool|select_only_this|DO_CALLBACK = 0

Make the given item be the current one. For the
L<MultiBrowser|FLTK::MultiBrowser> subclass this will turn off selection of
all other items and turn it on for this one and also set the focus here. If
the selection changes and C<L<when()|/"when">&L<do_callback|/"do_callback">>
is non-zero, the callback is done.

For the multibrowser, the callback is done for each item that changes, whether
it turns on or off.

=cut

bool
fltk::Browser::select_only_this ( DO_CALLBACK = 0 )
    int DO_CALLBACK

=for apidoc ||bool|selected|LINE

Does C<L<goto_index(line)|/"goto_index">,L<item_selected()|/"item_selected">>
to return the selection state of an item in a non-hierarchial
L<MultiBrowser|FLTK::MultiBrowser>. If line is out of range it returns
C<false>.

=cut

bool
fltk::Browser::selected ( LINE )
    int LINE

=for apidoc ||int|selected_column|

It will call the L<C<callback()>|/"callback"> if the user clicks on a column
title. Check this to see which one they clicked. This will return a negative
number if the callback is being done for some other reason, such as the user
clicking on an item.

=cut

int
fltk::Browser::selected_column ( )

=for apidoc ||int|set_column_start|COLUMN|X

NFI

=cut

int
fltk::Browser::set_column_start ( COLUMN, X )
    int COLUMN
    int X

=for apidoc ||bool|set_focus|

Change the focus (the selected item, or in an
L<FLTK::MultiBrowser|FLTK::MultiBrowser> the item that has a dotted box around
it, to the current item. This calls
L<C<make_item_visible()>|/"make_item_visible">.

=cut

bool
fltk::Browser::set_focus ( )

=for apidoc ||bool|set_item_opened|OPEN

If the current item is a parent, set the open state (the
L<FLTK::STATE|FLTK/"STATE"> flags) to the given value and redraw the browser
correctly. Returns C<true> if the state was actually changed, returns C<false>
if it was already in that state.

=cut

bool
fltk::Browser::set_item_opened ( OPEN )
    bool OPEN

=for apidoc ||bool|set_item_selected|VALUE = true|DO_CALLBACK = 0

This is for use by the L<MultiBrowser|FLTK::MultiBrowser> subclass. Turn the
L<C<FLTK::SELECTED>|FLTK/"SELECTED"> flag on or off in the current item (use
L<C<goto_index()>|/"goto_index"> to set the current item before calling this).

If this is not a L<MultiBrowser|FLTK::MultiBrowser>, this does
L<C<select_only_this()>|/"select_only_this"> if C<VALUE> is C<true>, and
L<C<deselect()>|/"deselect"> if C<VALUE> is C<false>.

If C<DO_CALLBACK> has some bits that are also in L<C<when()>|/"when"> then the
callback is done for each item that changes selected state.

=cut

bool
fltk::Browser::set_item_selected ( VALUE = true, DO_CALLBACK = 0 )
    bool VALUE
    int  DO_CALLBACK

=for apidoc ||bool|set_item_visible|VALUE

Turn off or on the LC<FLTK::INVISIBLE>|FLTK/"INVISIBLE"> flag on the given
item and redraw the browser if necessary. Returns C<true> if the state was
actually changed, returns C<false> if it was already in that state.

=cut

bool
fltk::Browser::set_item_visible ( VALUE )
    bool VALUE

#if 0

=for apidoc |||set_mark|DEST

NFI

=cut

void
fltk::Browser::set_mark ( DEST )
    Mark & DEST

=for apidoc |||set_mark_to_focus|DEST

NFI

=cut

void
fltk::Browser::set_mark_to_focus ( DEST )
    Mark & DEST

#endif


=for apidoc |||topline|LINE

Convenience function for non-hierarchial browsers. Make the indexed item
visible and scroll to put it at the top of the browser.

=cut

=for apidoc ||int|topline|

Convenience function for non-hierarchial browsers. Returns the index if the
top-level item that is at the top of the scrolling window.

=cut

int
fltk::Browser::topline ( LINE = NO_INIT )
    CASE: items
        int LINE
        CODE:
            THIS->topline( LINE );
    CASE:
        CODE:
            RETVAL = THIS->topline( );
        OUTPUT:
            RETVAL

=for apidoc ||int|value|

Returns L<C<focus_index(v)[0]>|/"focus_index">, to get the current item in a
non-hierarchial browser.

Reimplemented from L<FLTK::Menu|FLTK::Menu>.

=cut

=for apidoc |||value|VALUE

Same as C<L<goto_index(VALUE)|/"goto_index">;L<set_focus()|/"set_focus">;>, to
change the current item in a non-hierarchial browser.

=cut

int
fltk::Browser::value ( VALUE = NO_INIT )
    CASE: items
        int VALUE
        CODE:
            THIS->value( VALUE );
    CASE:
        CODE:
            RETVAL = THIS->value( );
        OUTPUT:
            RETVAL

=for apidoc ||int|width|

The width of the longest item in the browser, measured in pixels. If this is
changed (by adding or deleting items or opening or closing a parent item) then
L<C<layout()>|/"layout"> must be called before this is correct.

=cut

int
fltk::Browser::width ( )

=for apidoc |||xposition|X

Set the horizontal scrolling position, measured in pixels. Zero is the normal
position where the left edge of the child widgets is visible.

=cut

#if 0

=for apidoc ||int|xposition|

Returns the horizontal scrolling position, measured in pixels. Zero is the
normal position where the left edge of the child widgets is visible.

=cut

int
fltk::Browser::xposition ( X = NO_INIT )
    CASE: items
        int X
        CODE:
            THIS->xposition( X );
    CASE:
        CODE:
            RETVAL = THIS->xpositon( );
        OUTPUT:
            RETVAL



=for apidoc |||yposition|Y

Set the vertical scrolling position, measured in pixels. Zero means the top of
the first item is visible. Positive numbers scroll the display up.

=cut

=for apidoc ||int|yposition|

Returns the vertical scrolling position, measured in pixels. Zero means the
top of the first item is visible. Positive numbers scroll the display up.

=cut

int
fltk::Browser::yposition ( Y = NO_INIT )
    CASE: items
        int Y
        CODE:
            THIS->yposition( Y );
    CASE:
        CODE:
            RETVAL = THIS->ypositon( );
        OUTPUT:
            RETVAL

#endif

 # Public Attributes

#if 0

=for apidoc ||FLTK::Scrollbar|hscrollbar|

NFI

=cut

fltk::Scrollbar
fltk::Browser::hscrollbar ( )
    CODE:
        RETVAL = THIS->hscrollbar;
    OUTPUT:
        RETVAL

=for apidoc ||FLTK::Scrollbar|scrollbar|

NFI

=cut

fltk::Scrollbar
fltk::Browser::scrollbar ( )
    CODE:
        RETVAL = THIS->scrollbar;
    OUTPUT:
        RETVAL

#endif

 #Static Public Attributes

=for apidoc ||FLTK::NamedStyle|default_style|

NFI

=cut

fltk::NamedStyle *
fltk::Browser::default_style ( )
    CODE:
        RETVAL = THIS->default_style;
    OUTPUT:
        RETVAL

 #Protected Member Functions

#if 0 // protected

=for apidoc h|||handle_callback|DOIT

Protected Member Function

=cut

void
handle_callback ( DOIT )
    int DOIT

#endif


=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut

#endif
