MODULE = FLTK               PACKAGE = FLTK::Image

=pod

=head1 Description

A rectangular buffer of pixels that can be efficiently drawn on the screen.
The L<C<draw()>|/"draw"> functions will copy (or "over" composite if there is
alpha in the L<C<pixeltype()>|/"pixeltype">) onto the output, transformed by
the current transform.

NOTE: If you already have a set of pixels sitting in your own memory,
L<C<drawimage()>|/"drawimage"> can draw it and is much easier to use. You
should use this class only if you will be drawing the same image multiple
times, with no changes to the pixels.

The buffer is created and filled in by setting the type of pixels with
L<C<setpixeltype()>|/"setpixeltype">, the size with
L<C<setsize()>|/"setsize">, and then calling L<C<buffer()>|/"buffer"> (note
that L<C<setpixels()>|/"setpixels"> calls L<C<buffer()>|/"buffer"> for you).
The initial buffer is filled with undefined contents.

The best way to put data into the buffer is to make one or more calls to
L<C<setpixels()>|/"setpixels">, to replace rectangular regions.

You can directly address the L<C<buffer()>|/"buffer"> to read and write the
pixels. The size of the buffer is in L<C<buffer_width()>|/"buffer_width"> and
L<C<buffer_height()>|/"buffer_height"> (this may be much larger than
L<C<width()>|/"width"> and L<C<height()>|/"height">) and the distance between
lines is in L<C<buffer_linedelta()>|/"buffer_linedelta">. If you change any
pixels you should call L<C<buffer_changed()>|/"buffer_changed"> before the
next L<C<draw()>|/"draw">.

Due to operating system limitations, L<C<buffer()>|/"buffer"> is usually not
an array of L<C<pixeltype()>|/"pixeltype"> pixels. Instead
L<C<setpixels()>|/"setpixels"> converts pixels into a type the operating
system can use. The type of pixels in the buffer is retured by
L<C<buffer_pixeltype()>|/"buffer_pixeltype">. This is really inconvienent, so
you can also call the method L<C<force_ARGB32_on()>|/"force_ARGB32_on">. This
will cause L<C<buffer_pixeltype()>|/"buffer_pixeltype"> to return C<ARGB32>,
so you can assume this at compile time. The implementation of
L<Image|FLTK::Image> may be less efficient (actually the overhead is zero on
Windows and close to zero on most other systems).

If L<C<buffer()>|/"buffer"> has not been called, L<C<draw()>|/"draw"> will
call the L<C<fetch()>|/"fetch"> virtual method. It should call
L<C<setpixeltype()>|/"setpixeltype">, L<C<setsize()>|/"setsize"> and
L<C<setpixels()>|/"setpixels">. This is used to defer reading image files or
decompressing data until needed. L<C<fetch()>|/"fetch"> will also restore the
buffer contents to the original values if you have written to the buffer. If
L<C<fetch()>|/"fetch"> does not allocate a buffer, L<C<draw()>|/"draw"> will
draw a solid rectangle in the current color.

Because L<Image|FLTK::Image> is a subclass of L<Symbol|FLTK::Symbol>, it may
be used as a L<C<Widget::image()>|FLTK::Widget/"image"> or as the
L<C<box()>|FLTK::Style/"box"> in a L<Style|FLTK::Style>. If you give it a name
it can be drawn with C<@name;> in a label. If resized, the
C<L<Symbol|FLTK::Symbol> L<_draw()|/"_draw">> method will use the
L<C<inset()>|/"inset"> call to decide on edge thicknesses and will dice the
image up into C<9> individually-scaled pieces, which is very useful for GUI
buttons and background images (this is similar to how Flash draws buttons).

There are a number of subclasses such as L<jpgImage|FLTK::jpgImage> and
L<pngImage|FLTK::pngImage> that display compressed image data, either from
in-memory data buffers or from files.

Inherits L<FLTK::Symbol|FLTK::Symbol>.

Inherited by L<FLTK::rgbImage|FLTK::rbgImage>,
L<FLTK::SharedImage|FLTK::SharedImage>, L<FLTK::xbmImage|FLTK::xbmImage>, and
L<FLTK::xpmImage|FLTK::xpmImage>.

=cut

#include <fltk/Image.h>

=for apidoc ||FLTK::Image|new|NAME = 0

The default constructor sets L<C<pixeltype()>|/"pixeltype"> to C<RGB32>
(C<0x00rrggbb>) and L<C<width()>|/"width"> and L<C<height()>|/"height"> to
C<12>. This means that C<12x12> square with the current color will be drawn if
not able to draw anything else.

The optional C<NAME> is passed to the L<Symbol|FLTK::Symbol> constructor and
allows the image to be drawn by putting C<@name;> into a label.

=cut

=for apidoc ||FLTK::Image|new|WIDTH|HEIGHT|NAME = 0

Does L<C<setsize(WIDTH, HEIGHT)>|/"setsize">. This causes the
L<C<width()>|/"width"> and L<C<height()>|/"height"> to return the passed
values. No buffer is allocated, call L<C<buffer()>|/"buffer"> to do that. The
L<C<pixeltype()>|/"pixeltype"> is set to C<RGB32> (C<0x00rrggbb>).

=cut

=for apidoc ||FLTK::Image|new|PIXELTYPE|WIDTH|HEIGHT|NAME = 0

Does L<C<pixeltype( PIXELTYPE )>|/"pixeltype"> and
L<C<setsize( WIDTH, HEIGHT )>|/"setsize">. No buffer is allocated, call
L<C<buffer()>|/"buffer"> to do that.

=cut

=for apidoc ||FLTK::Image|new|DATA|PIXELTYPE|WIDTH|HEIGHT

Initializes the size and pixels by doing L<C<setimage()>|/"setimage">. Note
that the pointer data may be used unchanged. If you want to force a copy you
should use L<C<setpixels()>|/"setpixels"> instead.

=cut

=for apidoc ||FLTK::Image|new|DATA|PIXELTYPE|WIDTH|HEIGHT|LINEDELTA

Initializes the size and pixels by doing L<C<setimage()>|/"setimage">. Note
that the pointer data may be used unchanged. If you want to force a copy you
should use L<C<setpixels()>|/"setpixels"> instead.

=cut

fltk::Image *
fltk::Image::new ( ICHI = NO_INIT, NI = NO_INIT, SAN = NO_INIT, YON = NO_INIT, GO = NO_INIT )
    CASE: items <= 2
        const char * ICHI
        CODE:
            RETVAL = new fltk::Image( ICHI );
        OUTPUT:
            RETVAL
    CASE: items <= 4
        int          ICHI
        int          NI
        const char * SAN
        CODE:
            RETVAL = new fltk::Image( ICHI, NI, SAN );
        OUTPUT:
            RETVAL
    CASE: ( items <= 5 ) && ( SvIOK( ST(4) ) )
        const uchar *   ICHI
        fltk::PixelType NI
        int             SAN
        int             YON
        CODE:
            RETVAL = new fltk::Image( ICHI, NI, SAN, YON );
        OUTPUT:
            RETVAL
    CASE: items <= 5
        fltk::PixelType ICHI
        int             NI
        int             SAN
        const char    * YON
        CODE:
            RETVAL = new fltk::Image( ICHI, NI, SAN, YON );
        OUTPUT:
            RETVAL
    CASE: items == 6
        const uchar   * ICHI
        fltk::PixelType NI
        int             SAN
        int             YON
        int             GO
        CODE:
            RETVAL = new fltk::Image( ICHI, NI, SAN, YON, GO );
        OUTPUT:
            RETVAL

#if ALLOW_DESTROY

bool
fltk::Image::DESTROY ( )
    CODE:
#if VERBOSE >= 2
        warn ( "Bye, Image" );
#endif
        delete THIS;
        RETVAL = true;
    OUTPUT:
        RETVAL

#endif

 # Public Member Functions

=for apidoc |||_draw|RECT

Resizes the image to fit in the rectangle. This is the virtual method from the
L<Symbol|FLTK::Symbol> base class, so this is what is called if the image is
used as a label or box type.

If the destination rectangle is not the same size, L<C<inset()>|/"inset"> is
used to figure out the edge thicknesses. The image is then diced into C<9>
rectangles in a C<3x3> grid by the insets, and each piece is scaled
individually. This is very useful for scaling paintings of buttons. Note that
if the insets are zero (the default) then the whole image is scaled as one
piece. If you want, L<C<inset()>|/"inset"> can return different thicknesses
depending on the size, producing very interesting scaling.

It is possible this will use L<C<drawflags(INACTIVE)>|/"drawflags"> to gray
out the image in a system-specific way. NYI.

Implements L<FLTK::Symbol|FLTK::Symbol>.

=cut

void
fltk::Image::_draw ( RECT )
    const fltk::Rectangle * RECT
    C_ARGS: ( const fltk::Rectangle & ) RECT

=for apidoc |||_measure|WIDTH|HEIGHT

Returns L<C<width()>|/"width"> and L<C<height()>|/"height">.

The default constructor sets an internal flag that indicates that
L<C<fetch()>|/"fetch"> must be called before the L<C<width()>|/"width"> and
L<C<height()>|/"height"> are known. This is useful for subclasses that read a
file and figure out both the size and pixels at the same time.

Reimplemented from L<FLTK::Symbol|FLTK::Symbol>.

=cut

void
fltk::Image::_measure ( WIDTH, HEIGHT )
    int WIDTH
    int HEIGHT

=for apidoc ||DATA|buffer|

Creates (if necessary) and returns a pointer to the internal pixel buffer.
This is probably going to be shared memory with the graphics system, it may
have a different pixeltype, size, and linedelta than the L<Image|FLTK::Image>.
If you are able to figure out the type you can read and write the pixels
directly.

=cut

const char *
fltk::Image::buffer ( )
    CODE:
        RETVAL = ( const char * ) THIS->buffer( );
    OUTPUT:
        RETVAL

=for apidoc |||buffer_changed|

Call this if you modify the contents of L<C<buffer()>|/"buffer">. On some
systems the memory is not actually shared with the window system, and this
will cause L<C<draw()>|/"draw"> to copy the buffer to the system's memory.
L<C<setpixels()>|/"setpixels"> calls this for you.

=cut

void
fltk::Image::buffer_changed ( )

=for apidoc ||int|buffer_depth|

Returns the number of bytes per pixel stored in L<C<buffer()>|/"buffer">. This
is the same as
C<L<depth(L<buffer_pixeltype()|/"buffer_pixeltype">)|/"depth">>.

=cut

int
fltk::Image::buffer_depth ( )

=for apidoc ||int|buffer_height|

Return the height in pixels of L<C<buffer()>|/"buffer">.

=cut

int
fltk::Image::buffer_height ( )

=for apidoc ||int|buffer_linedelta|

Return the distance between each row of pixels in L<C<buffer()>|/"buffer">.

=cut

int
fltk::Image::buffer_linedelta ( )

=for apidoc ||FLTK::PixelType|buffer_pixeltype|

Return the type of pixels stored in L<C<buffer()>|/"buffer">. Likely to be
L<C<ARGB32>/"ARGB32">. On older (non-XRender) X system the types C<1> and C<2>
indicate C<1> and C<2>-byte data, but there is no api to figure out anything
more about this data.

=cut

fltk::PixelType
fltk::Image::buffer_pixeltype ( )

=for apidoc ||int|buffer_width|

Return the width in pixels of L<C<buffer()>|/"buffer">.

=cut

int
fltk::Image::buffer_width ( )

=for apidoc |||clear_forceARGB32|

NFI

=cut

void
fltk::Image::clear_forceARGB32 ( )

=for apidoc ||int|depth|

Same as C<L<depth(L<pixeltype()|/"pixeltype">)|/"depth">>, this returns how
many bytes each pixel takes in the buffer sent to
L<C<setpixels()>|/"setpixels">.

=cut

int
fltk::Image::depth ( )

=for apidoc |||destroy|

Destroys the L<C<buffer()>|/"buffer"> and any related system structures.

=cut

void
fltk::Image::destroy ( )

=for apidoc |||draw|FROM|TO

Draws the subrectangle from of the image, transformed to fill the rectangle
to (as transformed by the CTM). If the image has an alpha channel, an "over"
operation is done.

Due to lame graphics systems, this is not fully operational on all systems:
X11 without XRender extension: no transformations are done, the image is
centered in the output area. X11 with XRender: rotations fill the bounding box
of the destination rectangle, drawing extra triangular areas outside the
source rectangle. Somewhat bad filtering when making images smaller.
L<xbmImage|FLTK::xbmImage> does not transform. Windows: Only scaling, no
rotations. Bad filtering. xbmImage does not do any transformations. OS/X:
works well in all cases.

=cut

=for apidoc |||draw|FROM|

NFI

=cut

=for apidoc |||draw|X|Y

Does L<C<measure()>|/"measure"> and then
C<draw(FLTK::Rectangle(0, 0, w, h), FLTK::Rectangle( X, Y, w, h)>. Thus the
top-left corner is placed at C<X, Y> and no scaling (other than due to the
current transformation) is done.

=cut

void
fltk::Image::draw ( FROM, TO = NO_INIT )
    CASE: items == 2
        const fltk::Rectangle * FROM
        C_ARGS: ( const fltk::Rectangle & ) FROM
    CASE: ( items == 3 ) && ( SvIOK( ST(2) ) ) && ( SvIOK( ST(3) ) )
        int FROM
        int TO
    CASE: items == 3
        const fltk::Rectangle * FROM
        const fltk::Rectangle * TO
        C_ARGS: ( const fltk::Rectangle & ) FROM, ( const fltk::Rectangle & ) TO

=for apidoc ||bool|fetch|

This is called by the L<C<draw()>|/"draw"> functions once after the
L<Image|FLTK::Image> is created or after L<C<refetch()>|/"refetch"> has been
called. This allows subclasses to defer reading files and calling
L<C<setpixels()>|/"setpixels"> calls until the first L<C<draw()>|/"draw"> or
L<C<measure()>|/"measure">. This should return true if successful, false on
any error (though fltk does not do anything useful with errors).

The base class does nothing and returns C<true>, thus leaving the image
unchanged.

Sample implementation:

 package MyImage;

 # ...

 sub fetch {
    $self->setsize(
        $self->get_width($file),
        $self->get_height($file)
    );
    $self->setpixeltype($my_pixeltype);
    for my $y (0 .. $self->height()) {
      my $buffer = $self->linebuffer(y);
      $self->get_line_of_pixels($file, $buffer, $y);
      $self->setpixels($buffer, $y);
    }
    return 1;
  }

=cut

bool
fltk::Image::fetch ( )

=for apidoc |||fetch_if_needed|

Call L<C<fetch()>|/"fetch"> if it has not been called or if
L<C<refetch()>|/"refetch"> was called.

=cut

void
fltk::Image::fetch_if_needed ( )

=for apidoc ||bool|fills_rectangle|

Returns C<true> if the pixeltype does not support alpha.

Reimplemented from L<FLTK::Symnbol|FLTK::Symbol>.

=cut

bool
fltk::Image::fills_rectangle ( )

=for apidoc ||bool|forceARGB32|

NFI

=cut

bool
fltk::Image::forceARGB32 ( )

=for apidoc ||int|h|

NFI

=cut

bool
fltk::Image::h ( )

=for apidoc ||int|height|

Return the height of the image in pixels. You can change this with
L<C<setsize()>|/"setsize">.

=cut

=for apidoc |d||label|WIDGET

This is a 1.1 back-compatability function. It is the same as doing
C<$widget->image(this)> and C<widget->label(0)>.

=cut

void
fltk::Image::label ( WIDGET )
    fltk::Widget * WIDGET

=for apidoc ||char *|linebuffer|Y

Return a pointer to a buffer that you can write up to L<C<width()>|/"width">
pixels in L<C<pixeltype()>|/"pixeltype"> to and then call
L<C<setpixels(buffer, y)>|/"setpixels"> with. This can avoid doing any copying
of the data if the internal format and L<C<pixeltype()>|/"pixeltype"> are
compatable, because it will return a pointer directly into the buffer and
setpixels will detect this and do nothing.

=cut

char *
fltk::Image::linebuffer ( Y )
    int Y
    CODE:
        RETVAL = ( char * ) THIS->linebuffer( Y );
    OUTPUT:
        RETVAL

=for apidoc |||make_current|

NFI

=cut

void
fltk::Image::make_current ( )

=for apidoc ||unsigned long|mem_used|

Returns how much memory the image is using for L<C<buffer()>|/"buffer"> and
for any other structures it created. Returns zero if L<C<buffer()>|/"buffer">
has not been called.

=cut

unsigned long
fltk::Image::mem_used ( )

=for apidoc ||FLTK::PixelType|pixeltype|

Return the type of pixels that are put into the image with
L<C<setpixels()>|/"setpixels">. You can change this with
L<C<setpixeltype()>|/"setpixeltypes">. It is possible the internal data is in
a different type, use L<C<buffer_pixeltype()>|/"buffer_pixeltypes"> to find
out what that is.

=cut

fltk::PixelType
fltk::Image::pixeltype ( )

=for apidoc |||refetch|

Cause LC<fetch()>|/"fetch"> to be called again. This is useful for a file
image if the file name or contents have changed.

=cut

void
fltk::Image::refetch ( )

=for apidoc |||set_forceARGB32|

NFI

=cut

void
fltk::Image::set_forceARGB32 ( )

=for apidoc |||setimage|DATA|PIXELTYPE|WIDTH|HEIGHT

Figures out linedelta for you as C<WIDTH * depth( PIXELTYPE )>.

=cut

=for apidoc |||setimage|DATA|PIXELTYPE|WIDTH|HEIGHT|LINEDELTA

This is equivalent to:

  $self->setsize( WIDTH, HEIGHT );
  $self->setpixeltype( PIXELTYPE );
  $self->setpixels( DATA, FLTK::Rectangle->new( WIDTH, HEIGHT ), LINEDELTA );

...except, if possible, C<DATA> is used as L<C<buffer()>|/"buffer"> (throwing
away the const!). This will happen if the C<PIXELTYPE> and C<LINEDELTA> are of
types that it can handle unchanged and if the image memory does not need to be
allocated by the system.

=cut

void
fltk::Image::setimage ( DATA, PIXELTYPE, WIDTH, HEIGHT, LINEDELTA = NO_INIT )
    CASE: items == 5
        const uchar *   DATA
        fltk::PixelType PIXELTYPE
        int             WIDTH
        int             HEIGHT
        C_ARGS: DATA, PIXELTYPE, WIDTH, HEIGHT
    CASE:
        const uchar *   DATA
        fltk::PixelType PIXELTYPE
        int             WIDTH
        int             HEIGHT
        int             LINEDELTA

=for apidoc |||setpixels|DATA|Y

Same as
C<$self->setpixels(DATA, FLTK::Rectangle->new(0, Y, $self->width(),1))>, sets
one entire row of pixels.

=cut

=for apidoc |||setpixels|DATA|RECT

Figures out the linedelta for you as C<depth() * RECT->w()>.

=cut

=for apidoc |||setpixels|DATA|RECT|LINEDELTA

Replace the given rectangle of L<C<buffer()>|/"buffer"> with the supplied
data, which must be in the L<C<pixeltype()>|/"pixeltype">. C<LINEDELTA> is the
distance between each row of pixels in data. The rectangle is assummed to fit
inside the L<C<width()>|/"width"> and L<C<height()>|/"height">.

=cut

void
fltk::Image::setpixels ( DATA, Y, LINEDELTA = NO_INIT )
    CASE: SvIOK( ST(2) )
        const uchar * DATA
        int           Y
        C_ARGS: DATA, Y
    CASE: items == 3
        const uchar           * DATA
        const fltk::Rectangle * Y
        C_ARGS: DATA, ( const fltk::Rectangle & ) Y
    CASE:
        const uchar           * DATA
        const fltk::Rectangle * Y
        int                     LINEDELTA
        C_ARGS: DATA, ( const fltk::Rectangle & ) Y, LINEDELTA

=for apidoc |||setpixeltype|PIXELTYPE

Change the stored pixeltype. If it is not compatable then
L<C<destroy()>|/"destroy"> is called.

=cut

void
fltk::Image::setpixeltype ( PIXELTYPE )
    fltk::PixelType PIXELTYPE

=for apidoc |||setsize|WIDTH|HEIGHT

Change the size of the stored image. If it is not compatable with the current
data size (generally if it is larger) then L<C<destroy()>|/"destory"> is
called.

=cut

void
fltk::Image::setsize ( WIDTH, HEIGHT )
    int WIDTH
    int HEIGHT

=for apidoc ||int|w|

NFI

=cut

int
fltk::Image::w ( )

=for apidoc ||int|width|

Return the width of the image in pixels. You can change this with
L<C<setsize()>|/"setsize">.

=cut

int
fltk::Image::width ( )

 # Static Public Member Functions

=for apidoc ||unsigned long|total_mem_used|

Sum of all L<C<mem_used()>|/"mem_used"> calls to all L<Images|FLTK::Image>.
This is used by L<SharedImage|FLTK::SharedImage> to decide when to clear out
cached images.

=cut

unsigned long
fltk::Image::total_mem_used ( )

=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut
