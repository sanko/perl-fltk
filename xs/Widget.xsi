#ifndef DISABLE_WIDGET

MODULE = FLTK               PACKAGE = FLTK::Widget

=pod

=head1 Description

The base class for all widgets in FLTK. The basic Widget draws an empty
L<C<box()>|/"box"> and the L<C<label()>|/"label">, and ignores all events.
This can be useful for making decorations or providing areas that pop up a
L<C<tooltip()>|/"tooltip">.

Inherits L<FLTK::Widget|FLTK::Widget>.

Inherited by L<BButton|FLTK::BButton>, L<FLTK::CheckButton|FLTK::CheckButton>,
L<FLTK::HighlightButton|FLTK::HighlightButton>,
L<FLTK::RepeatButton|FLTK::RepeatButton>,
L<FLTK::ReturnButton|FLTK::ReturnButton>, and
L<FLTK::ToggleButton|FLTK::ToggleButton>.

=cut

#include <fltk/Widget.h>

=for apidoc ||FLTK::Widget|new|x|y|w|h|label = ''

The default constructor takes a value for L<C<x()>|/"x">, L<C<y()>|/"y">,
L<C<w()>|/"w">, and L<C<h()>|/"h">, and an optional value for
L<C<label()>|/"label">. Not that all subclasses provide an identical
constructor and may also provide alternative constructors.

If L<C<FLTK::Group->begin()>|FLTK::Group/"begin"> has been called, this widget
is added as a new child of that group, and L<C<parent()>|/"parent"> is set to
the group. If L<C<FLTK::Group->begin()>|FLTK::Group/"begin"> has not been
called, or L<C<FLTK::Group->end()>|FLTK::Group/"end"> has been called,
or L<C<FLTK::Group->current(0)>|FLTK::Group/"current">, then the
L<C<parent()>|/"parent"> is undef. In this case you must add the widget
yourself in order to see it.

=cut

Widget *
Widget::new( int x, int y, int w, int h, char *label = 0)
    CODE:
        RETVAL = new Widget( x, y, w, h, label);
        RETVAL->copy_label(label);
#if VERBOSE >= 2
        warn("%s|%s", RETVAL->label(), label);
#endif
    OUTPUT:
        RETVAL

#ifdef ENABLE_DESTROY

bool
Widget::DESTROY ( )
    CODE:
#if VERBOSE >= 2
        warn ( "Bye, Widget (label: '%s')", THIS->label());
#endif // #if VERBOSE >= 2
        delete THIS;
        RETVAL = true;
    OUTPUT:
        RETVAL

#endif // #ifdef ENABLE_DESTROY

=for apidoc ||FLTK::Group|parent|

Returns the parent widget. Usually this is a L<FLTK::Group|FLTK::Group> or
L<FLTK::Window|FLTK::Window>. Returns C<undef> if this is an orphan widget.

=cut

Group *
Widget::parent ( )

=for apidoc ||bool|contains|child

Returns a true value if L<widget|FLTK::Widget> C<child> is a child of this
widget, or is equal to this widget. Returns a false value if C<child> is
undefined.

=for apidoc ||bool|inside|parent

Returns true if this is a child of C<parent>, or is equal to C<parent>.
Returns false if C<parent> is undef.

=cut

bool
Widget::contains ( Widget * child )
    ALIAS:
        inside = 1
    CODE:
        switch( ix ) {
            case 0: RETVAL = THIS->contains(child); break;
            case 1: RETVAL = THIS->inside(child);   break;
        }
    OUTPUT:
        RETVAL

=for apidoc |||get_absolute_rect|rect

Fills the L<FLTK::Rectangle|FLTK::Rectangle> pointed to by C<rect> with the
widget's rectangle expressed in absolute (i.e. screen) coordinates.

=cut

void
Widget::get_absolute_rect( fltk::Rectangle * rect )

=for apidoc |||label|string

Sets the label directly to a string. The label is printed somewhere on the
widget or next to it. The string passed to label() is I<not> copied, instead
the pointer to the string is stored. If L<C<copy_label()>|/"copy_label"> was
called earlier the old string's memory is freed.

=for apidoc |||tooltip|string

Set the string used as the pop-up tooltip. The pointer to the passed string
is stored, it is not copied! Passing null indicates that the tooltip of the
L<C<parent()>|/"parent"> should be used (or no tooltip if no parent has one).
If you want to disable the tooltip but let the parent have one, set this
tooltip to C<"">.

Putting C<@> commands in to bring up L<Symbol|FLTK::Symbol> objects will allow
a lot of interesting things to be put into the tooltip.

=cut

const char *
Widget::label ( char * STRING = NO_INIT )
    CASE: items == 1
        CODE:
            switch( ix ) {
                case 0: RETVAL = THIS->label( );   break;
                case 1: RETVAL = THIS->tooltip( ); break;
            }
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            switch( ix ) {
                case 0: THIS->label( STRING );   break;
                case 1: THIS->tooltip( STRING ); break;
            }
    ALIAS:
        tooltip = 1

=for apidoc |||copy_label|string

Sets the label to a copy of the string. The passed string is copied to private
storage and used to set the L<C<label()>|/"label">. The memory will be freed
when the widget is destroyed or when L<C<copy_label()>|/"copy_label"> is
called again, or L<C<label(const char*)>|/"label"> is called.

Passing C<undef> will set L<C<label()>|/"label"> to C<undef>.

=cut

void
Widget::copy_label( char * STRING )

=for apidoc |||image|image

Sets the image. The C<image> is drawn as part of the label, usually to the
left of the text. This is designed for icons on menu items. If you want to
replace the entire background of the widget with a picture you should set
L<C<box()>|/"box"> instead. Notice that you can also get images into labels by
putting C<@> commands into the L<C<label()>|/"label">.

=cut

#include <fltk/Image.h>

void
Widget::image ( Image * image )

=for apidoc |||callback|coderef|args

Each widget has a single callback. You can set it or examine it with these
methods. The callback is called with the widget as the first argument and any
data in C<args> as the second argument. It is called in response to user
events, but exactly when depends on the widget. For instance a button calls it
when the button is released.

B<NOTE>: To make use of callbacks, your perl must be recent enough to support
weak references.

=for apidoc |||callback|coderef|

For convenience you can also define the callback as taking only the Widget as
an argument.

B<NOTE>: This may not be portable to some machines.

=cut

void
Widget::callback( CV * SUB, SV * ARGS = NO_INIT )
    CODE:
#ifdef ENABLE_CALLBACKS
        SV * widget = newSVsv((SV*)ST(0));
        sv_rvweaken(widget);
        AV *arr = newAV();
        av_push(arr, newSVsv((SV*)ST(1))); // coderef
        av_push(arr, widget); // widget
        if ( items == 3 )
            av_push(arr, newSVsv(ARGS));
        THIS->callback(_cb_w, (void *) arr);
#else  // ifdef ENABLE_CALLBACKS
        warn("Callbacks have been disabled."); // TODO: Expain why in POD
#endif // ifdef ENABLE_CALLBACKS

=for apidoc |||user_data|args

Set the second argument to the callback.

See Also: L<C<callback>|/"callback">, L<C<argument>|/"argument">.

=for apidoc |||argument|arg

Set the second argument to the callback to a number.

See Also: L<C<callback>|/"callback">, L<C<user_data>|/"user_data">.

=cut

void
Widget::user_data ( args )
    ALIAS:
        argument    = 1
    CODE:
        AV * arr = newAV();
        av_push(arr, av_shift((AV*)THIS->user_data()));
        SV * widget = newSVsv((SV*)ST(0));
#ifdef SvWEAKREF // XXX - Do I need to check this here? See FLTK::cb_w()
        sv_rvweaken(widget);
#else // ifdef SvWEAKREF
        croak("weak references are not implemented in this release of perl");
        XSRETURN_EMPTY;
#endif // ifdef SvWEAKREF
        av_push(arr, widget); // widget
        for (int i = 1; i < items; i++) {
            av_push(arr, newSVsv((SV*)ST(i)));
        }
        THIS->user_data(arr);

=for apidoc |||do_callback|

You can cause a widget to do its callback at any time.

=for apidoc x|||do_callback|Widget|args

You can also call the callback function with arbitrary arguments.

=cut

void
Widget::do_callback( Widget * widget = NO_INIT, SV * args = NO_INIT )
    CASE: items == 1
        CODE:
            THIS->do_callback( );
    CASE:
        CODE:
            SV * _widget = newSVsv((SV*)ST(1));
#ifdef SvWEAKREF // XXX - Do I need to check this here? See FLTK::cb_w()
            sv_rvweaken(_widget);
#else // ifdef SvWEAKREF
        croak("weak references are not implemented in this release of perl");
        XSRETURN_EMPTY;
#endif // ifdef SvWEAKREF
            AV  * arr     = newAV();
            if (THIS->user_data() == NULL) // if THIS has no cb, do nothing
                return;
            SV ** coderef = av_fetch((AV*)THIS->user_data(), 0, 0);
            av_push(arr, newSVsv(*coderef));
            av_push(arr, _widget);
            if ( items == 3 )
                av_push(arr, newSVsv(args));
            THIS->do_callback(widget, (void *) arr);

=for apidoc ||uchar|type|

C<8>-bit identifier that controls how widget works. This value had to be
provided for Forms compatibility, but you can use it for any purpose you want
(mostly for "bad object oriented programming" where you insert some subclass
functionality into the base class). Widget subclasses may store values in the
range C<0-99> here (larger values are reserved for use by FLTK).

The L<FLTK::PackedGroup|FLTK::PackedGroup> widget uses the low bit of the
L<C<type()>|/"type"> of each child to indicate C<HORIZONTAL (1)> or
C<VERTICAL (0)>.

For portability, FLTK does not use RTTI (Run Time Typing Infomation)
internally (you are free to use it, though). If you don't have RTTI you can
use the clumsy FLTK mechanisim, by having L<C<type()>|/"type"> use a unique
value. These unique values must be greater than the symbol
C<FLTK::Widget::RESERVED_TYPE> (which is C<100>). Look through the header
files for C<FLTK::Widget::RESERVED_TYPE> to find an unused number. If you
make a subclass of L<FLTK::Window|FLTK::Window>, you must use
C<FLTK::Widget::WINDOW_TYPE + N> (C<N> must be in the range C<1> to C<7>) so
that L<C<is_window()>|/"is_window"> will work, if you make a subclass of
L<FLTK::Group|FLTK::Group>, you must use C<FLTK::Widget::GROUP_TYPE + N> (C<N>
must be in the range C<1> to C<7>) so that L<C<is_group()>|/"is_group"> will
work.

=cut

uchar
Widget::type( )
    OUTPUT:
        RETVAL

=for apidoc ||bool|is_group|

Returns a true value for subclasses of L<FLTK::Group|FLTK::Group>.

=for apidoc ||bool|is_window|

Returns a true value for subclasses of L<FLTK::Window|FLTK::Window>. If this
is true, L<C<is_group()>|/"is_group"> is also true.

=cut

bool
Widget::is_group( )
    ALIAS:
        is_window = 1
    CODE:
        switch( ix ) {
            case 0: RETVAL = THIS->is_group();  break;
            case 1: RETVAL = THIS->is_window(); break;
        }
    OUTPUT:
        RETVAL

=for apidoc ||FLTK::Flags|flags|

Each Widget, and most drawing functions, take a bitmask of flags that indicate
the current state and exactly how to draw things. See <fltk/Flags.h> for
values.

This is for copying the flag values, use L<C<flag(c)>|/"flag"> to test them.

=for apidoc |||flags|f

Replace L<C<flags()>|/"flags">. This is for constructors, don't use it
elsewhere.

=cut

Flags
Widget::flags( Flags f = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->flags( );
            OUTPUT:
                RETVAL
    CASE:
        CODE:
            THIS->flags( f );


=for apidoc |||set_flag|f

Make L<C<flag(f)>|/"flag"> return true by turning on that bit. You can set
more than one by or'ing them together.

=for apidoc |||clear_flag|f

Make L<C<flag(f)>|/"flag"> return false by turning off that bit. You can turn
off multiple bits by or'ing them toegher.

=for apidoc |||set_flag|f|b

Make L<C<flag(f)>|/"flag"> return C<b>. Same as
C<b ? set_flag(f) : clear_flag(f)>.

=for apidoc |||invert_flag|f

Flip the result of L<C<flag(f)>|/"flag"> if C<f> is a single bit. If you or
together bits it will flip them all.

=cut

void
Widget::set_flag( unsigned f, bool b = NO_INIT )
    CASE: items == 2
        CODE:
            switch( ix ) {
                case 0: THIS->set_flag( f );    break;
                case 1: THIS->clear_flag( f );  break;
                case 2: THIS->invert_flag( f ); break;
            }
    CASE:
        CODE:
            switch( ix ) {
                case 0: THIS->set_flag( f, b ); break;
            }
    ALIAS:
        clear_flag  = 1
        invert_flag = 2

=for apidoc ||bool|flag|f

Returns true if the bit for C<f> is on.

=for apidoc ||bool|any_of|f

Returns true if I<any> of the bits in C<f> are on. Actually, this is the same
function as L<C<flag(f)>|/"flag"> but using this may make the code more
readable.

=for apidoc ||bool|all_of|f

Returns true if I<all> of the bits in C<f> are on. C<f> should be several bits
or'd together, otherwise this is the same as L<C<flag(f)>|/"flag">.

=cut

bool
Widget::flag( unsigned f )
    ALIAS:
        any_of = 1
        all_of = 2
    CODE:
        switch( ix ) {
            case 0: RETVAL = THIS->flag( f ); break;
            case 1: RETVAL = THIS->any_of( f ); break;
            case 2: RETVAL = THIS->all_of( f ); break;
        }
    OUTPUT:
        RETVAL

=for apidoc |||align|flags

Forces the values of all the C<FLTK::ALIGN_*> flags to the passed value. This
determines how the label is printed next to or inside the widget. The default
value is C<FLTK::ALIGN_CENTER>, which centers the label. The value can be any
of the C<ALIGN> flags or'd together.

=cut

void
Widget::align( Flags flags )


=for apidoc |||when|flag

Flags indicating when to do the L<C<callback()>|/"callback">. This field is in
the base class so that you can scan a panel and
L<C<do_callback()>|/"do_callback"> on all the ones that don't do their own
callbacks in response to an C<OK> button.

The following constants can be used, their exact meaning depends on the
widget's implementation:

=over

=item C<FLTK::WHEN_NEVER>

Never call the L<C<callback (0)>|/"callback">.

=item C<FLTK::WHEN_CHANGED>

Do the callback each time the widget's value is changed by the user (many
callbacks may be done as the user drags the mouse)

=item C<FLTK::WHEN_RELEASE>

Each keystroke that modifies the value, or when the mouse is released and the
value has changed, causes the callback (some widgets do not implement this and
act like L<FLTK::WHEN_CHANGED>)

=item C<FLTK::WHEN_RELEASE_ALWAYS>

Each recognized keystroke and the mouse being released will cause the
callback, even if the value did not change. (some widgets do not implement
this and act like C<FLTK::WHEN_RELEASE>)

=item C<FLTK::WHEN_ENTER_KEY>

Do the callback when the user presses the C<ENTER> key and the value has
chagned (used by L<FLTK::Input|FLTK::Input> and
L<FLTK::Browser|FLTK::Browser>).

=item C<FLTK::WHEN_ENTER_KEY_ALWAYS>

Do the callback when the user presses the C<ENTER> key, even if the value has
not changed.

=item C<FLTK::WHEN_ENTER_KEY_CHANGED>

Do the callback when the user presses the C<ENTER> key and each time the value
changes.

=back

=cut

void
Widget::when ( uchar flag )

=for apidoc ||bool|resize|X|Y|W|H

Change the size or position of the widget. Nothing is done if the passed size
and position are the same as before. If there is a change then
L<C<relayout()>|/"relayout"> is called so that the virtual function
L<C<layout()>|/"layout"> is called before the next L<C<draw()>|/"draw">.

=for apidoc ||bool|resize|W|H

Same as L<C<resize( x(), y(), $W, $H)>|/"resize">.

=cut

bool
Widget::resize ( int X = NO_INIT, int Y = NO_INIT, int W, int H )
    CASE: items == 3
        CODE:
            RETVAL = THIS->resize( X, Y, W, H );
    CASE: items == 5
        CODE:
            RETVAL = THIS->resize( W, H );
    OUTPUT:
        RETVAL

=for apidoc ||bool|positon|X|Y

Same as L<C<resize( X, Y, w(), h() )>|/"resize">

=cut

bool
Widget::position ( int X, int Y )
    OUTPUT:
        RETVAL

=for apidoc |||relayout|

Same as L<C<relayout(LAYOUT_DAMAGE)>|/"relayout">, indicates that data inside
the widget may have changed, but the size did not change. This flag is also on
when the widget is initially created.

=for apidoc |||relayout|flags

Cause L<C<layout()>|/"layout"> to be called later. Turns on the specified
flags in L<C<layout_damage()>|/"layout_damage">, and turns on C<LAYOUT_CHILD>
in all parents of this widget. C<flags> cannot be zero, the maaning of the
flags is listed under F<fltk/layout.h>.

=cut

void
Widget::relayout( uchar flags = NO_INIT )
    CASE: items == 1
        CODE:
            THIS->relayout( );
    CASE:
        C_ARGS: flags

=for apidoc ||uchar|layout_damage|

The 'or' of all the calls to L<C<relayout()>|/"relayout"> or
L<C<resize()>|/"resize"> done since the last time L<C<layout()>|/"layout"> was
called.

A typical layout function does not care about the widget moving, an easy way
to skip it is as follows:

    package MyWidget; # XXX - Untested
    { # ... ISA stuff, etc. ...
        sub layout {
            my ($self) = @_;
            return if !($self->layout_damage() & ~LAYOUT_XY);
            do_expensive_layout();
            $self->redraw();
        }
    }

=for apidoc |||layout_damage|flag

Directly change the value returned by L<C<layout_damage()>|/"layout_damage">.

=cut

uchar
Widget::layout_damage ( uchar VALUE = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->layout_damage( );
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            THIS->layout_damage( VALUE );

=for apidoc ||bool|horizontal|

Return true if this widget has a horizontal orientation and
L<FLTK::Pack|FLTK::Pack> will position it agains the top or bottom edge. This
is the default.

See also: L<C<vertical()>|/"vertical">

=for apidoc ||bool|vertical|

Same as L<C<!horizontal()>|/"horizontal">

=cut

bool
Widget::horizontal( )
    ALIAS:
        vertical = 1
    CODE:
        switch( ix ) {
            case 0: RETVAL = THIS->horizontal(); break;
            case 1: RETVAL = THIS->vertical();   break;
        }
    OUTPUT:
        RETVAL

=for apidoc |||set_vertical|

Makes L<C<vertical()>|/"vertical"> return true. This will affect how a
surrounding L<FLTK::Pack|FLTK::Pack> (or similar group) will place the widget,
but you must call L<C<relayout()>|/"relayout"> to indicate that this must be
recalculated.

Some widgets classes such as L<FLTK::MenuBar|FLTK::MenuBar> or
L<FLTK::Slider|FLTK::Slider> will draw differently if this is turned on, in a
vertical arrangement.

=for apidoc |||set_horizontal|

Undoes L<C<set_vertical()>|/"set_vertical"> and makes
L<C<horizontal()>|/"horizontal"> return true. This will affect how a
surrounding L<FLTK::Pack> (or similar group) will place the widget, but you
must call L<C<relayout()>|/"relayout"> to indicate that this must be
recalculated.

=cut

void
Widget::set_vertical ( )
    ALIAS:
        set_horizontal = 1
    CODE:
        switch ( ix ) {
            case 0: THIS->set_vertical();   break;
            case 1: THIS->set_horizontal(); break;
        }

    # Push these into the top level

MODULE = FLTK               PACKAGE = FLTK

=for apidoc e|||DAMAGE_CHILD|

A child of this group widget needs to be redrawn (non-group widgets can use
this bit for their own purposes).

=for apidoc e|||DAMAGE_CHILD_LABEL|

An outside label of this widget needs to be redrawn. This is handled (and this
bit is cleared) by the parent group.

Because anti-aliasing cannot be redrawn atop itself, this is not
used anymore. Instead if an outside label needs to change the entire
parent widget is redrawn.

=for apidoc e|||DAMAGE_EXPOSE|

Damage caused by L<C<damage()>|/"damage"> or by expose events from the
operating system. If this and L<C<FLTK::DAMAGE_ALL>|/"DAMAGE_ALL"> is on the
widget should draw every pixel inside it's region.

=for apidoc e|||fltk::DAMAGE_ALL|

This bit is set by L<C<redraw()>|/"redraw"> and indicates that all of the
widget (but not "holes" where the background shows through) needs to be
redraw.

=for apidoc e|||DAMAGE_VALUE|

A widget may use this to indicate that the displayed value has changed.

=for apidoc e|||DAMAGE_PUSHED|

A widget may use this to indicate that the user has pushed or released a
button.

=for apidoc e|||DAMAGE_SCROLL|

A widget may use this to indicate that the displayed data has scrolled moved
horizontally and/or vertically.

=for apidoc e|||DAMAGE_OVERLAY|

Same value as L<C<FLTK::DAMAGE_SCROLL>|/"FLTK::DAMAGE_SCROLL">.

=for apidoc e|||DAMAGE_HIGHLIGHT

A widget may use this to indicate that the mouse has entered/exited part of
the widget.

=for apidoc e|||DAMAGE_CONTENTS

Same as L<C<FLTK::DAMAGE_EXPOSE>|/"DAMAGE_EXPOSE"> but if
L<C<FLTK::DAMAGE_ALL>|/"FLTK::DAMAGE_ALL"> is off a widget can use this for
it's own purposes.

=cut

#include <fltk/damage.h>

uchar
DAMAGE_CHILD( )
    CODE:
        switch( ix ) {
            case 0: RETVAL = DAMAGE_CHILD;       break;
            case 1: RETVAL = DAMAGE_CHILD_LABEL; break;
            case 2: RETVAL = DAMAGE_EXPOSE;      break;
            case 3: RETVAL = DAMAGE_ALL;         break;
            case 4: RETVAL = DAMAGE_VALUE;       break;
            case 5: RETVAL = DAMAGE_SCROLL;      break;
            case 6: RETVAL = DAMAGE_OVERLAY;     break;
            case 7: RETVAL = DAMAGE_HIGHLIGHT;   break;
            case 8: RETVAL = DAMAGE_CONTENTS;    break;
        }
    OUTPUT:
        RETVAL
    ALIAS:
        DAMAGE_CHILD_LABEL = 1
        DAMAGE_EXPOSE      = 2
        DAMAGE_ALL         = 3
        DAMAGE_VALUE       = 4
        DAMAGE_SCROLL      = 5
        DAMAGE_OVERLAY     = 6
        DAMAGE_HIGHLIGHT   = 7
        DAMAGE_CONTENTS    = 8

MODULE = FLTK               PACKAGE = FLTK::Widget

    # ...and welcome back to the show.

=for apidoc ||uchar|damage|

The 'or' of all the calls to L<C<redraw()>|/"redraw"> done since the last
L<C<draw()>|/"draw">. Cleared to zero after L<C<draw()>|/"draw"> is called.

=cut

uchar
Widget::damage( )
    OUTPUT:
        RETVAL

=for apidoc |||set_damage|c

Directly change the value returned by L<C<damage()>|/"damage">. Note that this
I<replaces> the value, it does not turn bits on. Use L<C<redraw()>|/"redraw">
to turn bits on.

=cut

void
Widget::set_damage( uchar c )


=for apidoc |||redraw|

Same as C<redraw(DAMAGE_ALL)>. This bit is used by most widgets to indicate
that they should not attempt any incremental update, and should instead
completely draw themselves.

=for apidoc |||redraw|flags

Indicates that L<C<draw()>|/"draw"> should be called, and turns on the given
bits in L<C<damage()>|/"damage">. At least these bits, and possibly others,
will still be on when L<C<draw()>|/"draw"> is called.

=cut

void
Widget::redraw( uchar flags = DAMAGE_ALL )

=for apidoc |||redraw_label|

Indicates that the L<C<label()>|/"label"> should be redrawn. This does nothing
if there is no label. If it is an outside label (see L<C<align()>|/"align">)
then the L<C<parent()>|/"parent"> is told to redraw it. Otherwise
L<C<redraw()>|/"redraw"> is called.

=for apidoc |||redraw_highlight|

Causes a redraw if highlighting changes.

Calls L<C<redraw(DAMAGE_HIGHLIGHT)>|/"redraw"> if this widget has a non-zero
L<C<highlight_color()>|/"hightlight_color">. This is designed to be called in
response to C<ENTER >and C<EXIT> events and not redraw the widget if the no
highlight color is being used.

=cut

void
Widget::redraw_label( )
    CODE:
        switch ( ix ) {
            case 0: THIS->redraw_label();     break;
            case 1: THIS->redraw_highlight(); break;
        }
    ALIAS:
        redraw_highlight = 1

=for apidoc ||int|handle|event

Handle an event. Returns non-zero if the widget understood and used the event.

The event numbers are listed in F<fltk/events.h>.  All other information about
the current event (like mouse position) is accessed by various functions
listed in the same header file.

The default version returns true for C<FLTK::ENTER> and C<FLTK::MOVE> events,
this is done so you can put tooltips on the base widget. All other events
return zero.

If you want to send an event to a widget you probably want to call
L<C<send()>|/"send">, not L<C<handle()>|/"handle">. Send will do extra work
with each event before calling this, such as turning C<HIGHLIGHT> and
C<FOCUSED> flags on/off.

=for apidoc ||int|send|event

Wrapper for L<C<handle()>|/"handle">. This should be called to send events. It
does a few things:

=over

=item It calculates L<C<event_x()>|/"event_x">/L<C<event_y()>|/"event_y"> to
be relative to the widget. The previous values are restored before this
returns.

=item It makes sure the widget is active and/or visible if the event requres
this.

=item If this is not the L<C<FLTK::belowmouse()>|FLTK/"belowmouse"> widget
then it changes C<FLTK::MOVE> into C<FLTK::ENTER> and turns C<FLTK::DND_DRAG>
into C<FLTK::DND_ENTER>. If this I<is> the
L<C<FLTK::belowmouse()>|FLTK/"belowmouse"> widget then the opposite conversion
is done.

=item For move, focus, and push events if L<C<handle()>|/"handle"> returns
true it sets the L<C<FLTK::belowmouse()>|FLTK/"belowmouse"> or
L<C<FLTK::focus()>|FLTK/"focus"> or L<C<FLTK::pushed()>|FLTK/"pushed"> widget
to reflect this.

=back

=cut

int
Widget::handle( int event )
    CODE:
        switch ( ix ) {
            case 0: RETVAL = THIS->handle( event ); break;
            case 1: RETVAL = THIS->send( event );   break;
        }
    OUTPUT:
        RETVAL
    ALIAS:
        send = 1

=for apidoc |||add_timeout|time

Call L<C<handle(TIMEOUT)>|/"handle"> at the given time in the future. This
will happen exactly once. To make it happen repeatedly, call
L<C<repeat_timeout()>|/"repeat_timeout"> from inside
L<C<handle(TIMEOUT)>|/"handle">.

=for apidoc |||repeat_timeout|time

Call L<C<handle(TIMEOUT)>|/"handle"> at the given time interval since the last
timeout. This will produce much more accurate time intervals than
L<C<add_timeout>|/"add_timeout">.

=cut

void
Widget::add_timeout( float time )
    CODE:
        switch ( ix ) {
            case 0: THIS->add_timeout( time );    break;
            case 1: THIS->repeat_timeout( time ); break;
        }
    ALIAS:
        repeat_timeout = 1

=for apidoc |||remove_timeout|

Cancel any and all pending L<C<handle(TIMEOUT)>|/"handle"> callbacks.

=for apidoc |||activate|

If L<C<active()>|/"active"> is false, this turns it on. If
L<C<active_r()>|/"active_r"> is now true L<C<send()>|/"send"> an
C<FLTK::ACTIVATE> event.

=for apidoc |||deactivate|

If L<C<active()>|/"active"> is true, this turns it off. If
L<C<active_r()>|/"active_r"> was true L<C<send()>|/"send"> an
C<FLTK::DEACTIVATE> event.

=for apidoc |||show|

If L<C<visible()>|/"visible"> is false, turn it on. If
L<C<visible_r()>|/"visible_r"> is then true, L<C<send()>|/"send"> a
C<FLTK::SHOW> event.

=for apidoc |||hide|

If L<C<visible()>|/"visible"> is true, turn it off. If
L<C<visible_r()>|/"visible_r"> was true then L<C<send()>|/"send"> a
C<FLTK::HIDE> event, and L<C<redraw()>|/"redraw"> the parent if necessary.

=cut

void
Widget::remove_timeout( )
    CODE:
        switch( ix ) {
            case 0: THIS->remove_timeout( ); break;
            case 1: THIS->activate();        break;
            case 2: THIS->deactivate();      break;
            case 3: THIS->show();            break;
            case 4: THIS->hide();            break;
        }
    ALIAS:
          activate = 1
        deactivate = 2
              show = 3
              hide = 4

=for apidoc ||bool|active|

Returns true if L<C<deactivate()>|/"deactivate"> has not been called, or
L<C<activate()>|/"activate"> has been called since then.

Parents may also be deactivated, in which case this widget will not get events
even if this is true. You can test for this with
C<!>L<C<active_r()>|/"active_r">.

=for apidoc ||bool|active_r|

Returns true if L<C<active()>|/"active"> is true for this and all parent
widgets. This is actually the C<INACTIVE_R> bit in L<C<flags()>|/"flags">,
fltk keeps this up to date as widgets are deactivated and/or added to inactive
parents.

=for apidoc ||bool|output|

This flag is similar to L<C<!active()>|/"active"> except it does not change
how the widget is drawn. The widget will not recieve any events. This is
useful for making scrollbars or buttons that work as displays rather than
input devices.

Set or clear this flag with L<C<set_output()>|/"set_output"> and
L<C<clear_output()>|/"clear_output">.

=for apidoc ||bool|visible|

Returns true if the widget is visible (L<C<flag(INVISIBLE)>|/"flag"> is
false).

=for apidoc ||bool|visible_r|

Returns true if the widget and all of its parents are visible. Only if this is
true can the user see the widget.

=for apidoc ||bool|takesevents|

This is the same as C<(active() && visible() && output())> but faster.
L<C<send()>|/"send"> uses this to decide whether or not to call
L<C<handle()>|/"handle"> for most events.

=for apidoc ||bool|click_to_focus|

If true then clicking on this widget will give it the focus (the
L<C<handle()>|/"handle"> method must also return non-zero for C<FLTK::PUSH>
and for C<FLTK::FOCUS> events).

By default fltk only turns this on on certain widgets such as
L<FLTK::Input|FLTK::Input>. Turning this on on all widgets will make the user
interface match Windows more closely.

=for apidoc ||bool|tab_to_focus|

If true then this widget can be given focus by keyboard navigation. (the
L<C<handle()>|/"handle"> method must also return non-zero for
C<FLTK::FOCUS> events).

Turning this off with L<C<clear_tab_to_focus()>|/"clear_tab_to_focus"> will
also turn off the L<C<click_to_focus()>|/"click_to_focus"> flag. This is for
compatability in case we change the default to a more Windows-like style where
all widgets get the focus on clicks.

For historical reasons this flag is true on many more widgets than it should
be, and FLTK relies on L<C<handle()>|/"handle"> returing C<0> for C<FOCUS>.
This may change in the future so that more widgets have this flag off.

=for apidoc ||bool|changed|

The default L<C<callback()>|/"callback"> turns this flag on. This can be used
to find what widgets have had their value changed by the user, for instance in
response to an "OK" button.

Most widgets turn this flag off when they do the callback, and when the
program sets the stored value.

=for apidoc H||bool|value|

A true/false flag used by L<FLTK::Button|FLTK::Button> to indicate the current
state and by "parent" items in a hierarchial L<FLTK::Browser|FLTK::Browser> to
indicate if they are open. Many widgets will draw pushed-in or otherwise
indicate that this flag is on.

=for hackers For some reason, this is documented in fltk but it doesn't
actually exist in this class

=for apido ||bool|selected|

A true/false flag used to mark widgets currently selected in
L<FLTK::Menu|FLTK::Menu> and L<FLTK::Browser|FLTK::Browser> widgets. Some
widgets will draw with much different colors if this is on.

=cut

bool
Widget::active( )
    CODE:
        switch ( ix ) {
            case  0: RETVAL = THIS->active();         break;
            case  1: RETVAL = THIS->active_r();       break;
            case  2: RETVAL = THIS->output();         break;
            case  3: RETVAL = THIS->visible();        break;
            case  4: RETVAL = THIS->visible_r();      break;
            case  5: RETVAL = THIS->takesevents();    break;
            case  6: RETVAL = THIS->click_to_focus(); break;
            case  7: RETVAL = THIS->tab_to_focus();   break;
            case  8: RETVAL = THIS->changed();        break;
          //case  9: RETVAL = THIS->value();          break;
            case 10: RETVAL = THIS->selected();       break;
        }
    OUTPUT:
        RETVAL
    ALIAS:
              active_r =  1
                output =  2
               visible =  3
             visible_r =  4
           takesevents =  5
        click_to_focus =  6
          tab_to_focus =  7
               changed =  8
                 value =  9
              selected = 10



































#if 0












void
Widget::layout ( )

bool
Widget::copy_style ( STYLE )
    const Style * STYLE



Window *
Widget::window ( )



unsigned
Widget::shortcut ( KEY )
    CASE: ! items
        C_ARGS:
    CASE: items == 1
        unsigned KEY
        CODE:
            THIS->shortcut( KEY );

bool
Widget::add_shortcut ( KEY )
    unsigned KEY

bool
Widget::remove_shortcut ( KEY )
    unsigned KEY

void
Widget::remove_shortcuts ( )

unsigned
Widget::label_shortcut ( )

bool
Widget::test_label_shortcut ( )

bool
Widget::test_shortcut ( TEST_LABEL )
    CASE: ! items
        CODE:
            THIS->test_shortcut( );
    CASE: items == 1
        bool TEST_LABEL

 # TODO: Make this look more like the C++ version
 # void
 # Widget::default_callback ( WIDGET, CODE )
 #     Widget * WIDGET
 #     CODE:
 #         AV *arr = newAV();
 #         av_store(arr, 0, newSVsv((SV*)ST(1))); // coderef
 #         av_store(arr, 1, newSVsv((SV*)ST(0))); // widget
 #         for (int i = 2; i < items; i++) {
 #             warn ( "%d | %s", i, newSVsv((SV*)ST(i)));
 #             av_store(arr, i, newSVsv((SV*)ST(i)));
 #         }
 #         THIS->default_callback(WIDGET, cb);
 #         THIS->user_data(arr);

bool
Widget::state ( STATE )
    CASE: ! items
        CODE:
            RETVAL = THIS->state( );
    CASE:
        bool STATE;

void
Widget::draw_label ( RECTANGLE, FLAGS )
    CASE: ! items
        PROTOTYPE: $;$$
        CODE:
            THIS->draw_label( );
    CASE: items == 2
        const fltk::Rectangle * RECTANGLE
        Flags                   FLAGS
        C_ARGS: (const fltk::Rectangle &) RECTANGLE, FLAGS

void
Widget::draw_glyph ( WHICH, RECTANGLE )
    int WHICH
    const fltk::Rectangle * RECTANGLE
    C_ARGS: WHICH, (const fltk::Rectangle &) RECTANGLE

void
Widget::cursor ( CURSOR )
    Cursor * CURSOR

void
Widget::measure_label ( W, H )
    int W
    int H
    OUTPUT:
        W
        H

 # TODO: Make these work...

 # void
 # Widget::add ( ATYPE, DATA )
 #     const AssociationType * ATYPE
 #     void * DATA
 #     C_ARGS: (const AssociationType) ATYPE, DATA
 #     OUTPUT:
 #         ATYPE
 #
 # bool
 # Widget::set ( ATYPE, DATA )
 #     CASE: ! items
 #         PROTOTYPE: $;$$
 #         CODE:
 #             RETVAL = THIS->set( );
 #     CASE:
 #           AssociationType * ATYPE
 #         void * DATA
 #         C_ARGS: (const AssociationType) ATYPE, DATA
 #         OUTPUT:
 #             ATYPE
 #
 # void *
 # Widget::get ( ATYPE )
 #     const AssociationType ATYPE
 #     OUTPUT:
 #         ATYPE
 #
 # void *
 # Widget::foreach (   AssociationType & AT, AssociationFunctor & FKT )
 #
 # bool
 # Widget::remove (   AssociationType & AT, void * DATA )
 #
 # bool
 # Widget::find (   AssociationType & AT, void * DATA )

















































bool
Widget::add_shorcut( unsigned key )
    CODE:
        THIS->add_shortcut( key );
    OUTPUT:
        RETVAL




 # From fltk::Rectangle

int
Widget::x ( int x = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->x( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->x( x );
            RETVAL = THIS->x( ) == x ? true : false;
        OUTPUT:
            RETVAL

int
Widget::y ( int y = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->y( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->y( y );
            RETVAL = THIS->y( ) == y ? true : false;
        OUTPUT:
            RETVAL

int
Widget::w ( int w = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->w( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->w( w );
            RETVAL = THIS->w( ) == w ? true : false;
        OUTPUT:
            RETVAL

int
Widget::h ( int h = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->h( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        CODE:
            THIS->h( h );
            RETVAL = THIS->h( ) == h ? true : false;
        OUTPUT:
            RETVAL

int
Widget::r ( ... )
    CODE:
        RETVAL = THIS->r( );
    OUTPUT:
        RETVAL

int
Widget::b ( ... )
    CODE:
        RETVAL = THIS->b( );
    OUTPUT:
        RETVAL

bool
Widget::set_x ( int v )
    CODE:
        THIS->set_x( v );
        RETVAL = THIS->x( ) == v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::set_y ( int v )
    CODE:
        THIS->set_y( v );
        RETVAL = THIS->y( ) == v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::set_r ( int v )
    CODE:
        THIS->set_r( v );
        RETVAL = THIS->r( ) == v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::set_b ( int v )
    CODE:
        THIS->set_b( v );
        RETVAL = THIS->b( ) == v ? true : false;
    OUTPUT:
        RETVAL

 # bool
 # Widget::set(int x, int y, int w, int h)
 #     CODE:
 #         THIS->set(x, y, w, h);
 #         RETVAL = (
 #             (THIS->x( ) == x) and
 #             (THIS->y( ) == y) and
 #             (THIS->w( ) == w) and
 #             (THIS->h( ) == h)) ? true : false;
 #     OUTPUT:
 #         RETVAL


bool
Widget::move_x ( int v )
    CODE:
        int pre_x = THIS->x( );
        THIS->move_x( v );
        RETVAL = THIS->x( ) == pre_x + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move_y ( int v )
    CODE:
        int pre_y = THIS->y( );
        THIS->move_y( v );
        RETVAL = THIS->y( ) == pre_y + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move_r ( int v )
    CODE:
        int pre_r = THIS->r( );
        THIS->move_r( v );
        RETVAL = THIS->r( ) == pre_r + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move_b ( int v )
    CODE:
        int pre_b = THIS->b( );
        THIS->move_b( v );
        RETVAL = THIS->b( ) == pre_b + v ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::inset ( int v )
    CODE:
        int pre_w = THIS->w( );
        int pre_h = THIS->h( );
        THIS->inset( v );
        RETVAL = (
            (THIS->w( ) == pre_w - (v * 2)) and
            (THIS->h( ) == pre_h - (v * 2))
          ) ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::move ( int dx, int dy )
    CODE:
        int pre_x = THIS->x( );
        int pre_y = THIS->y( );
        THIS->move( dx, dy );
        RETVAL = (
            (THIS->x( ) == pre_x + dx) and
            (THIS->y( ) == pre_y + dy)
          ) ? true : false;
    OUTPUT:
        RETVAL

bool
Widget::empty ( )
    CODE:
        RETVAL = THIS->empty( );
    OUTPUT:
        RETVAL

bool
Widget::not_empty ( )
    CODE:
        RETVAL = THIS->not_empty( );
    OUTPUT:
        RETVAL

int
Widget::center_y ( )
    CODE:
        RETVAL = THIS->center_y( );
    OUTPUT:
        RETVAL

int
Widget::baseline_y ( )
    CODE:
        RETVAL = THIS->baseline_y( );
    OUTPUT:
        RETVAL


 # TODO: void fltk::Rectangle::merge  (  const Rectangle &   r   )
 # Replace the value with the union of this rectangle and R (ie the rectangle
 # that surrounds both of these rectangles). If one rectangle is empty(), the
 # other is returned unchanged (ie it does not union in the degenerate point
 # of that rectangle).

 # TODO: void fltk::Rectangle::intersect  (  const Rectangle &   r   )
 # Replace the value with the intersection of this rectangle and R. If the
 # rectangles do not intersect, the result may have negative width and/or
 # height, this means empty() will return true, but some code may still draw
 # this rectangle.









 # Unknown...
float
Widget::labelsize( SIZE = 0 )
    CASE: items == 1
        CODE:
            RETVAL = THIS->labelsize( );
       OUTPUT:
            RETVAL
    CASE: items == 2
        int SIZE;
        CODE:
            THIS->labelsize(SIZE);

LabelType *
Widget::labeltype ( TYPE = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->labeltype( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        LabelType * TYPE
        CODE:
            THIS->labeltype( TYPE );

Font *
Widget::labelfont ( TYPE = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->labelfont( );
        OUTPUT:
            RETVAL
    CASE: items == 2
        Font * TYPE
        CODE:
            THIS->labelfont( TYPE );


int
Widget::color(int color = NO_INIT)
    CODE:
        if (items > 1) {
            //group->box(lookup_box(color));
            THIS->color(color);
            RETVAL = (color == THIS->color()) ? color : NULL;
        }
        else
            RETVAL = THIS->color();
    OUTPUT:
        RETVAL

void
Widget::box( TYPE )
    Box * TYPE


#endif

#endif // ifndef DISABLE_WIDGET


=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut
