#include <fltk/run.h>

int
READ ( )
    CODE:
        RETVAL = READ;

int
WRITE ( )
    CODE:
        RETVAL = WRITE;

int
EXCEPT ( )
    CODE:
        RETVAL = EXCEPT;

 # typedef void(* 	FileHandler )(int fd, void *)
 # typedef void(* 	TimeoutHandler )(void *)
 # int 	damage_


#if 1

=for apidoc Um|string|_help|

This is a portion of the string printed by L<fltk::args()> detects an invalid
argument on the command-line. You can add this to your own error or help
message to show the fltk switches. It's value is (no newline at start or the
end):

 -d[isplay] host:n.n
 -g[eometry] WxH+X+Y
 -n[ame] windowname
 -i[conic]
 -bg color

Note: Rather than using this private function, users should access the
L<$FLTK::help> variable.

=cut

char *
_help ( )
    CODE:
        RETVAL = (char *) fltk::help;
        //RETVAL = "This is a test";
    OUTPUT:
        RETVAL

#endif

 #void(* 	idle )()
 #void 	add_check (TimeoutHandler, void *=0)
 #void 	add_fd (int fd, FileHandler, void *=0)
 #void 	add_fd (int fd, int when, FileHandler, void *=0)
 #void 	add_idle (TimeoutHandler, void *=0)
 #void 	add_timeout (float t, TimeoutHandler, void *v=0)
 #int 	arg (int, char **, int &)
 #void 	args (int, char **)
 #int 	args (int, char **, int &, int(*)(int, char **, int &)=0)

=for apidoc A||awake|MESSAGE = 0

A child thread can call this to cause the main thread's call to L<wait()> to
return (with the lock locked) even if there are no events ready. The main
purpose of this is to get the main thread to redraw the screen, but it will
also cause L<wait()> to return so the program's code can do something.

You should call this immediatly before L<unlock()> for best performance.

The C<MESSAGE> aregument can be retrieved by the other thread using
L<thread_message()>.

=cut

void
awake ( MESSAGE = 0 )
    void * MESSAGE

=for apidoc A|int|check|

Same as L<wait(0)>. Calling this during a big calculation will keep the screen
up to date and the interface responsive:

 while (!calculation_done()) {
   calculate();
   FLTK::check();
   if (user_hit_abort_button( )) {break;}
 }

=cut

int
check ( )











 #int 	damage ()
 #void 	damage (int d)
 #void 	display (const char *)
 #bool 	enable_tablet_events ()
 #void 	flush ()


=for apidoc A||flush|

Writes all preferences to disk.

=over 8

=item this function works only with the base preference group

=item this function is rarely used as deleting the base preferences flushes
automatically

=back

Get the display up to date. This is done by calling L<layout()> on all
L<Window> objects with L<layout_damage()> and then calling L<draw()> on all
L<Window> objects with L<damage()>. (actually it calls L<Window::flush()> and
I<that> calls L<draw()>, but normally you can ignore this). This will also
flush the X i/o buffer, update the cursor shape, update Windows window sizes,
and other operations to get the display up to date.

L<wait()> calls this before it waits for events.

=cut

void
flush ( )



 #double 	get_time_secs ()
 #bool 	has_check (TimeoutHandler, void *=0)
 #bool 	has_idle (TimeoutHandler, void *=0)
 #bool 	has_timeout (TimeoutHandler, void *=0)
 #bool 	in_main_thread ()
 #void 	lock ()
 #int 	ready ()





=for apidoc A|int|ready|

Test to see if any events or callbacks are pending. This will return true if
L<FLTK::check()> would do anything other than update the screen. Since this
will not draw anything or call any code, it is safe to call this if your
program is in an inconsistent state. This is also useful if your calculation
is updating widgets but you do not want or need the overhead of the screen
updating every time you check for events.

  while (!calculation_done()) {
    calculate();
    if (FLTK::ready()) {
      do_expensive_cleanup();
      FLTK::check();
      if (user_hit_abort_button()){ break; }
    }
  }

=cut

int
ready ( )






 #void 	redraw ()
 #void 	remove_check (TimeoutHandler, void *=0)
 #void 	remove_fd (int, int when=-1)
 #void 	remove_idle (TimeoutHandler, void *=0)
 #void 	remove_timeout (TimeoutHandler, void *=0)
 #void 	repeat_timeout (float t, TimeoutHandler, void *=0)

=for apidoc A|int|run|

Calls L<FLTK::wait()> as long as any windows are not closed. When all the
windows are hidden or destroyed (checked by seeing if L<Window::first()> is
null) this will return with zero. A program can also exit by having a callback
call L<exit()> or L<abort()>.

Most FLTK programs will end with <exit FLTK::run();>.

=cut

int
run ( )

 #void 	set_idle (void(*cb)())
 #void * 	thread_message ()
 #void 	unlock ()
 #int 	wait (float time)
 #int 	wait ()












