#include <fltk/ask.h>

int
BEEP_DEFAULT ( )
    CODE:
        RETVAL = BEEP_MESSAGE;

int
BEEP_MESSAGE ( )
    CODE:
        RETVAL = BEEP_MESSAGE;

int
BEEP_ERROR ( )
    CODE:
        RETVAL = BEEP_QUESTION;

int
BEEP_QUESTION ( )
    CODE:
        RETVAL = BEEP_QUESTION;

int
BEEP_PASSWORD ( )
    CODE:
        RETVAL = BEEP_PASSWORD;

int
BEEP_NOTIFICATION ( )
    CODE:
        RETVAL = BEEP_NOTIFICATION;

=for apidoc U|string|cancel|

TODO

=cut

const char *
cancel ( WHAT = "" )
    CASE: items
        const char * WHAT
        CODE:
            RETVAL = (fltk::cancel = WHAT);
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = fltk::cancel;
        OUTPUT:
            RETVAL

#if 0

=for apidoc U|FLTK::NamedStyle|icon_style|

TODO

=cut

NamedStyle *
icon_style( )
    CODE:
        RETVAL = icon_style;

#endif

#if 0

=for apidoc U|FLTK::NamedStyle|message_style|

TODO

=cut

NamedStyle *
message_style ( )
    CODE:
        RETVAL = message_style;

#endif


=for apidoc ||message_window_label|

TODO

=cut

const char *
message_window_label ( WHAT = "" )
    CASE: items
        const char * WHAT
        CODE:
            RETVAL = (fltk::message_window_label = WHAT);
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = fltk::message_window_label;
        OUTPUT:
            RETVAL

=for apidoc ||message_window_scrollable|

TODO

=cut

bool
message_window_scrollable ( WHAT = fltk::message_window_scrollable )
    CASE: items
        bool WHAT
        CODE:
            RETVAL = (fltk::message_window_scrollable = WHAT);
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = fltk::message_window_scrollable;
        OUTPUT:
            RETVAL


=for apidoc ||message_window_timeout|

TODO

=cut

float
message_window_timeout ( WHAT = fltk::message_window_timeout )
    CASE: items
        float WHAT
        CODE:
            RETVAL = (fltk::message_window_timeout = WHAT);
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = fltk::message_window_timeout;
        OUTPUT:
            RETVAL

=for apidoc ||no|

You can change this string to convert fltk to a foreign language.

Referenced by L<ask()>.

=cut

const char *
no ( WHAT = "" )
    CASE: items
        const char * WHAT
        CODE:
            RETVAL = (fltk::no = WHAT);
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = fltk::no;
        OUTPUT:
            RETVAL


=for apidoc |STRING|ok|STRING

TODO

=cut

const char *
ok ( WHAT = "" )
    CASE: items
        const char * WHAT
        CODE:
            RETVAL = (fltk::ok = WHAT);
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            RETVAL = fltk::ok;
        OUTPUT:
            RETVAL


=for apidoc |STRING|yes|STRING

You can change this string to convert fltk to a foreign language.

Referenced by L<ask()>.

=cut

const char *
yes ( WHAT = "" )
    CASE: items
        const char * WHAT
        CODE:
            fltk::yes = WHAT;
    CASE:
        CODE:
            RETVAL = fltk::yes;
        OUTPUT:
            RETVAL

=for apidoc m|bool|message|STRING

Displays a message in a pop-up box with an "OK" button and waits for the user
to hit the button. The message will wrap to fit the window, or may be many
lines by putting C<\n> characters into it. The enter key is a shortcut for the
OK button.

=for Comments | This is a cheap interace to fltk::message( STRING )

=cut

void
_message ( string )
    const char * string;
    CODE:
        fltk::message( string );

void
_alert ( string )
    char * string;
    CODE:
        fltk::alert( string );

=for apidoc  m|bool|ask|STRING

Displays a message in a pop-up box with "Yes" and "No" buttons and waits
for the user to hit a button. The return value is C<1> if the user hits
Yes, C<0> if they pick No. The enter key is a shortcut for Yes and C<ESC>
is a shortcut for No.

If L<C<FLTK::message_window_timeout>|/"message_window_timeout"> is used,
then C<-1> will be returned if the timeout expires.

=cut

int
_ask ( string )
    const char * string;
    CODE:
        RETVAL = fltk::ask( string );
    OUTPUT:
        RETVAL

=for apidoc mx|int|choice|QUERY|CHOICE1|CHOICE2|CHOICE3

Shows the message with three buttons below it marked with the strings
C<CHOICE1>, C<CHOICE2>, and C<CHOICE3>. Returns C<0>, C<1>, or C<2>
depending on which button is hit. If one of the strings begins with the
special character 'C<*>' then the associated button will be the default
which is selected when the enter key is pressed. C<ESC> is a shortcut for
C<CHOICE2>.

If L<C<FLTK::message_window_timeout>|/"message_window_timeout"> is used,
then C<-1> will be returned if the timeout expires.

=cut

int
choice ( query, choice1, choice2, choice3 )
    const char * query;
    const char * choice1;
    const char * choice2;
    const char * choice3;

=for apidoc  mx|int|choice_alert|QUERY|CHOICE1|CHOICE2|CHOICE3

Same as
L<C<choice( )>|/"FLTK::choice( QUERY, CHOICE1, CHOICE2, CHOICE3 )">
except a "!" icon is used instead of a "?".
=cut

int
choice_alert ( query, choice1, choice2, choice3 )
    const char * query;
    const char * choice1;
    const char * choice2;
    const char * choice3;


=for apidoc  mx|int|input|QUERY|[DEFAULT]|[...]

Pops up a window displaying a string, lets the user edit it, and return
the new value. The cancel button returns C<undef>. The returned pointer
is only valid until the next time C<FLTK::input( )> is called. Due to
back-compatibility, the arguments to any printf commands in the label are
after the default value.

If L<C<FLTK::message_window_timeout>|/"message_window_timeout"> is used,
then C<-1> will be returned if the timeout expires.

=cut

const char *
_input ( query, DEFAULT = "" )
    const char * query;
    const char * DEFAULT;
    CODE:
        RETVAL = fltk::input(query, DEFAULT);
    OUTPUT:
        RETVAL

=for apidoc  mx||password|QUERY|[DEFAULT = ""]

Same as L<C<FLTK::input( )>|/FLTK::input( QUERY, [DEFAULT] [, ... ] )>
except an L<FLTK::SecretInput|FLTK::SecretInput> field is used.

=cut

const char *
_password ( query, DEFAULT = "" )
    const char * query;
    const char * DEFAULT;
    CODE:
        RETVAL = fltk::password(query, DEFAULT);
    OUTPUT:
        RETVAL

=for apidoc  m||beep|[TYPE]

Generates a simple beep message.

=cut

void
beep ( TYPE = BEEP_DEFAULT )
    int TYPE

=for apidoc mx||beep_on_dialog|[BEEP]

You get the enable state of beep on default message dialogs (like
L<ask|/"FLTK::ask( STRING )">,
L<ask|/"FLTK::choice( QUERY, CHOICE1, CHOICE2, CHOICE3 )">,
L<ask|/"FLTK::input( QUERY, [DEFAULT] [, ... ] )">, ...) by using this
function with C<true> (default is C<false>).

If C<BEEP> is defined, you set the enable state.

=cut

bool
beep_on_dialog( value = NO_INIT )
    CASE: items
        bool value;
        CODE:
            fltk::beep_on_dialog();
            RETVAL = RETVAL; // silence, please
    CASE: !items
        CODE:
            RETVAL = fltk::beep_on_dialog();
        OUTPUT:
            RETVAL

 #
 # Copyright (C) 2009 by Sanko Robinson <sanko@cpan.org>
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of The Artistic License 2.0.  See the LICENSE file
 # included with this distribution or
 # http://www.perlfoundation.org/artistic_license_2_0.  For
 # clarification, see http://www.perlfoundation.org/artistic_2_0_notes.
 #
 # When separated from the distribution, all POD documentation is covered by
 # the Creative Commons Attribution-Share Alike 3.0 License.  See
 # http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
 # clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.
 #
 # $Id: FLTK_ask.xsi e14ddfd 2009-03-31 04:47:22Z sanko@cpan.org $
 #
