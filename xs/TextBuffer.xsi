#ifndef DISABLE_TEXTBUFFER

MODULE = FLTK               PACKAGE = FLTK::TextBuffer

=pod

=for license Artistic License 2.0 | Copyright (C) 2009 by Sanko Robinson

=for author Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

=for version 0.532

=for git $Id$

=head1 NAME

FLTK::TextBuffer -

=head1 Description



=cut

#include <fltk/TextBuffer.h>

=head1 Constructor

=for apidoc d||FLTK::TextBuffer buffer|new|int requested_size|

Creates an empty text buffer of pre-determined size. Use this to avoid
unnecessary re-allocation if you know exactly how much the buffer will need to
hold.

=head2 Usage

=for markdown {%highlight perl%}

    my $buffer   = FLTK::TextBuffer->new( $requested_size );
    my $buffer_2 = FLTK::TextBuffer->new( 1027 * 256 );
    my $buffer_3 = FLTK::TextBuffer->new( );

=for markdown {%endhighlight%}

=cut

#include "include/WidgetSubclass.h"

void
fltk::TextBuffer::new( int requested_size = 0 )
    PPCODE:
        void * RETVAL = NULL;
        RETVAL = (void *) new fltk::TextBuffer( requested_size );
        if (RETVAL != NULL) {
            ST(0) = sv_newmortal();
            sv_setref_pv(ST(0), CLASS, RETVAL); /* -- hand rolled -- */
            XSRETURN(1);
        }

=head1 Methods

=head2 C<< my $length = $buffer->length( ) >>

=for apidoc ||int length|length||

=cut

int
fltk::TextBuffer::length( )

=pod

=head2 C<< my $txt = $buffer->text( ) >>
X<text>

=for apidoc ||const char * txt|text||

Return the entire contents of the text buffer.

=head2 C<< $buffer->text( $txt ) >>

=for apidoc |||text|const char * txt|

Replace the entire contents of the text buffer.

=cut

const char *
fltk::TextBuffer::text ( const char * txt = NO_INIT )
    CASE: items == 1
        CODE:
            RETVAL = THIS->text( );
        OUTPUT:
            RETVAL
    CASE:
        CODE:
            THIS->text( txt );

=pod
X<character>

=head2 C<< my $char = $buffer->character( $pos ) >>

=for apidoc ||char char|character|int pos|

Returns the character at buffer position C<$pos>. Positions start at C<0>.

=cut

char
fltk::TextBuffer::character( int pos )

=pod
X<text_range>

=head2 C<my $txt = $buffer-E<gt>text_range( $start, $end )>

=for apidoc ||char * txt|text_range|int start|int end|

Returns a copy of the text between C<$start> and C<$end> character positions.
Positions are C<0> (zero) based and the range does I<not> include the
character pointed to by C<$end>.

=cut

char *
fltk::TextBuffer::text_range( int start, int end )

=pod
X<text_in_rectangle>

=head2 C<my $txt = $bufferE<gt>text_in_rectangle( $start, $end, $rectStart, $rectEnd )>

=for apidoc ||char * txt|text_in_rectangle|int start|int end|int rectStart|int rectEnd|

Returns a copy of the text between C<$start> and C<$end> character positions.
Positions are C<0> (zero) based and the range does I<not> include the
character pointed to by C<$end>.

=cut

char *
fltk::TextBuffer::text_in_rectangle( int start, int end, int rectStart, int rectEnd )

=pod
X<insert>

=head2 C<$bufferE<gt>insert( $pos, $text )>

=for apidoc |||insert|int pos|const char * text|

Inserts string C<$text> at position C<$pos>.

=cut

void
fltk::TextBuffer::insert( int pos, const char * text )

=pod
X<append>

=head2 C<$bufferE<gt>append( $text )>

=for apidoc |||append|const char * text|

Appends C<$text> to the end of the buffer.

=cut

void
fltk::TextBuffer::append( const char * text )

=pod
X<remove>

=head2 C<$bufferE<gt>remove( $start, $end )>

=for apidoc |||remove|int start|int end|

Deletes the text between C<$start> and C<$end> character positions. Positions
are C<0> (zero) based and the range does I<not> include the character pointed
to by C<$end>.

=cut

void
fltk::TextBuffer::remove( int start, int end )

=pod
X<replace>

=head2 C<$bufferE<gt>replace( $start, $end, $text )>

=for apidoc |||replace|int start|int end|const char * text|

Deletes the characters between C<$start> and C<$end>, and inserts the string
C<$text> in their place.

=cut

void
fltk::TextBuffer::replace( int start, int end, const char * text )

=pod
X<copy>

=head2 C<$to_bufferE<gt>copy( $from_buffer, $from_start, $from_end, $to_pos )>

=for apidoc |||copy|fltk::TextBuffer * from_buffer|int from_start|int from_end|int to_pos|

Copy the characters between C<$from_start> and C<$from_end> in
C<$from_buffer>, and inserts the string into your object at C<$to_pos>.

=cut

void
fltk::TextBuffer::copy( fltk::TextBuffer * from_buffer, int from_start, int from_end, int to_pos )

=pod
X<undo>

=head2 C<my $okay = $bufferE<gt>undo( $cursorPosition )>

=for apidoc ||int okay|undo|int * cursorPosition = 0|

Removes text according to the undo variables or inserts text from the undo
buffer. C<$cursorPosition> will be set to the position of the cursor after
this change.

=cut

int
fltk::TextBuffer::undo( IN_OUT int cursorPosition = 0 )

=pod
X<canUndo>

=head2 C<$bufferE<gt>canUndo( $flag ) >

=for apidoc |||canUndo|char flag = 1|

Lets the undo system know if we can undo changes.

=cut

void
fltk::TextBuffer::canUndo( char flag = 1 )





INCLUDE: TextSelection.xsi

#endif // ifndef DISABLE_TEXTBUFFER
