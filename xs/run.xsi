#ifndef DISABLE_RUN

MODULE = FLTK               PACKAGE = FLTK

#include <fltk/run.h>

    # Side trip into FLTK::Widget

MODULE = FLTK               PACKAGE = FLTK::Widget

=for apidoc t[run]||bool|take_focus|

Tries to make this widget be the keyboard focus widget, by first sending it an
C<FLTK::FOCUS> event, and if it returns non-zero, setting
L<C<FLTK::focus()>|FLTK/"focus"> to this widget. You should use this method to
assign the focus to a widget. Returns true if the widget accepted the focus.

On current systems, fltk does not force the window system to set the focus. If
the window does not have focus it will usually switch back to the previous
window when the user types a key.

=cut

bool
Widget::take_focus()
    OUTPUT:
        RETVAL

MODULE = FLTK               PACKAGE = FLTK

    # ...and we're back.

=for apidoc t[run]|||add_timeout|time|callback|args

Add a one-shot timeout callback. The function will be called by
L<C<fltk::wait()>|FLTK/"wait"> at C<time> seconds after this function is
called. The optional C<args> are passed to the callback.

=for apidoc t[run]|||repeat_timeout|time|callback|args

Similar to L<C<add_timeout()>|/"add_timeout">, but rather than the time being
measured from "now", it is measured from when the system call elapsed that
caused this timeout to be called. This will result in far more accurate
spacing of the timeout callbacks, it also has slightly less system call
overhead. (It will also use all your machine time if your timeout code and
fltk's overhead take more than t seconds, as the real timeout will be reduced
to zero).

Outside a timeout callback this acts like L<C<add_timeout()>|/"add_timeout">.

This code will print "TICK" each second on C<*STDOUT>, with a fair degree of
accuracy:

    sub callback {
        printf("TICK\n");
        FLTK::repeat_timeout(1.0, \&callback);
    }
    FLTK::add_timeout(1.0, \&callback);
    FLTK::wait() while 1

=cut

void
add_timeout( double time, CV * callback, SV * args = NO_INIT )
    CODE:
        AV *arr = newAV();
        av_push(arr, newSVsv((SV*)ST(1))); // coderef
        if (items == 3) // Callbacks can be called without arguments
            av_push(arr, args );
        switch( ix ) {
            case 0:    add_timeout( time, _cb, (void *) arr ); break;
            case 1: repeat_timeout( time, _cb, (void *) arr ); break;
        }
    ALIAS:
        repeat_timeout = 1

=for apidoc Hxt[run]||bool|has_timeout|coderef|args

Returns true if the timeout exists and has not been called yet.

This doesn't work right now because I stuff perl's datatypes where I shouldn't
...I'll come back to it.

=cut

bool
has_timeout( CV * callback, SV * args = NO_INIT )
    CODE:
        AV *arr = newAV();
        av_push(arr, newSVsv((SV*)ST(0))); // coderef
        if (items == 2) // Callbacks can be called without arguments
            av_push(arr, args);
        /* for (Timeout* t = first_timeout; t; t = t->next)
            if (t->cb == _cb &&
                av_fetch(*(AV*)t->arg, 0, 0) == newSVsv((SV*)ST(0))
            ) {RETVAL = true; break; }
        }*/
        RETVAL = has_timeout(_cb, (void *) arr); // ...for now. It always returns false...
    OUTPUT:
        RETVAL












=for apidoc t[run] F|||run|

Calls L<C<FLTK::wait()>|/"wait"> as long as any windows are not closed. When
all the windows are hidden or destroyed (checked by seeing if
L<C<Window::first()>|FLTK::Window/"first"> is undef) this will return with
zero. A program can also exit by having a callback call C<exit()>.

Most FLTK programs will end with C<exit FLTK::run();>.

=cut

void
run ()





#endif // ifndef DISABLE_RUN

=pod

=head1 Author

Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/

CPAN ID: SANKO

=head1 License and Legal

Copyright (C) 2009 by Sanko Robinson E<lt>sanko@cpan.orgE<gt>

This program is free software; you can redistribute it and/or modify
it under the terms of The Artistic License 2.0.  See the F<LICENSE>
file included with this distribution or
http://www.perlfoundation.org/artistic_license_2_0.  For
clarification, see http://www.perlfoundation.org/artistic_2_0_notes.

When separated from the distribution, all POD documentation is covered
by the Creative Commons Attribution-Share Alike 3.0 License.  See
http://creativecommons.org/licenses/by-sa/3.0/us/legalcode.  For
clarification, see http://creativecommons.org/licenses/by-sa/3.0/us/.

=for git $Id$

=cut
